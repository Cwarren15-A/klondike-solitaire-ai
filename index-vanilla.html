<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Klondike Solitaire - AI Enhanced</title>
    <meta name="description" content="Play Klondike Solitaire with AI-powered hints, analysis, and adaptive difficulty. Advanced machine learning provides intelligent gameplay assistance.">
    
    <!-- Social Media Meta Tags -->
    <meta property="og:title" content="Klondike Solitaire - AI Enhanced">
    <meta property="og:description" content="Advanced Klondike Solitaire with AI-powered hints, complete board analysis, and machine learning assistance.">
    <meta property="og:image" content="https://raw.githubusercontent.com/yourusername/klondike-solitaire-ai/main/preview.png">
    <meta property="og:url" content="https://yourusername.github.io/klondike-solitaire-ai/">
    <meta property="og:type" content="website">
    
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Klondike Solitaire - AI Enhanced">
    <meta name="twitter:description" content="Advanced Klondike Solitaire with AI-powered hints and machine learning assistance.">
    <meta name="twitter:image" content="https://raw.githubusercontent.com/yourusername/klondike-solitaire-ai/main/preview.png">
    
    <!-- PWA Meta Tags -->
    <meta name="theme-color" content="#1e5128">
    <meta name="mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <meta name="apple-mobile-web-app-title" content="Solitaire AI">
    <link rel="apple-touch-icon" href="./public/icons/icon-192.png">
    <link rel="manifest" href="./public/manifest.json">
    
    <!-- Performance and SEO -->
    <meta name="robots" content="index, follow">
    <meta name="author" content="Your Name">
    <meta name="keywords" content="solitaire, klondike, card game, AI, machine learning, hints, analysis, free game">
    <link rel="canonical" href="https://yourusername.github.io/klondike-solitaire-ai/">
    
    <!-- Preload critical resources -->
    <link rel="preconnect" href="https://cdnjs.cloudflare.com">
    <link rel="dns-prefetch" href="https://cdnjs.cloudflare.com">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tensorflow/4.15.0/tf.min.js"></script>
    <style>
        * {
            box-sizing: border-box;
        }
        
        body {
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, var(--bg-primary, #1e5128), var(--bg-secondary, #2d5016));
            font-family: 'Arial', sans-serif;
            color: var(--text-color, white);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            overflow-x: auto;
            touch-action: none;
            transition: all 0.3s ease;
            user-select: none;
        }
        
        /* Default theme */
        body {
            --bg-primary: #1e5128;
            --bg-secondary: #2d5016;
            --card-color: #ffffff;
            --text-color: white;
        }
        
        .dark-theme {
            --bg-primary: #0f1419;
            --bg-secondary: #1a1a2e;
            --card-color: #ffffff;
            --text-color: white;
        }
        
        .light-theme {
            --bg-primary: #e3f2fd;
            --bg-secondary: #bbdefb;
            --card-color: #333333;
            --text-color: #333333;
        }
        
        .blue-theme {
            --bg-primary: #1e3a8a;
            --bg-secondary: #1e40af;
            --card-color: #ffffff;
            --text-color: white;
        }
        
        .game-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            max-width: 1000px;
            margin-bottom: 20px;
            font-size: 18px;
            font-weight: bold;
            flex-wrap: wrap;
            gap: 10px;
            animation: slideInDown 0.5s ease-out;
        }
        
        @keyframes slideInDown {
            from { transform: translateY(-30px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }
        
        @keyframes slideInUp {
            from { transform: translateY(30px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }
        
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
        }
        
        .stats {
            display: flex;
            gap: 20px;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .stat-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            background: rgba(255,255,255,0.1);
            padding: 8px 12px;
            border-radius: 8px;
            min-width: 80px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.2);
            transition: all 0.3s ease;
        }
        
        .stat-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }
        
        .stat-label {
            font-size: 12px;
            opacity: 0.8;
            margin-bottom: 2px;
        }
        
        .stat-value {
            font-size: 16px;
            font-weight: bold;
        }
        
        .controls {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        
        button {
            padding: 8px 16px;
            border: none;
            border-radius: 8px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            font-size: 14px;
        }
        
        button:focus-visible {
            outline: 2px solid #4ade80;
            outline-offset: 2px;
        }
        
        button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
            transition: left 0.5s;
        }
        
        button:hover::before {
            left: 100%;
        }
        
        button:active {
            transform: scale(0.95);
        }
        
        button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }
        
        .btn-blue { background: linear-gradient(135deg, #2563eb, #1d4ed8); color: white; }
        .btn-yellow { background: linear-gradient(135deg, #d97706, #b45309); color: white; }
        .btn-purple { background: linear-gradient(135deg, #7c3aed, #6d28d9); color: white; }
        .btn-green { background: linear-gradient(135deg, #059669, #047857); color: white; }
        .btn-orange { background: linear-gradient(145deg, #f97316, #ea580c); color: white; }
        .btn-red { background: linear-gradient(135deg, #dc2626, #b91c1c); color: white; }
        
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none !important;
        }
        
        #gameCanvas {
            border: 3px solid #4ade80;
            border-radius: 15px;
            background: radial-gradient(ellipse at center, #166534 0%, #14532d 100%);
            box-shadow: 0 15px 35px rgba(0,0,0,0.4);
            cursor: default;
            display: block;
            animation: slideInUp 0.5s ease-out;
            transition: all 0.3s ease;
        }
        
        #gameCanvas:hover {
            box-shadow: 0 20px 40px rgba(0,0,0,0.5);
        }
        
        .menu {
            background: rgba(0,0,0,0.85);
            backdrop-filter: blur(20px);
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            box-shadow: 0 25px 50px rgba(0,0,0,0.6);
            border: 1px solid rgba(255,255,255,0.1);
            animation: slideInUp 0.6s ease-out;
            max-width: 90vw;
            max-height: 90vh;
            overflow-y: auto;
        }
        
        .menu h1 {
            font-size: clamp(24px, 5vw, 48px);
            margin-bottom: 30px;
            color: #4ade80;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            animation: pulse 2s infinite;
        }
        
        .menu button {
            display: block;
            width: min(250px, 80vw);
            margin: 10px auto;
            padding: 15px;
            font-size: 18px;
            transform: translateY(20px);
            animation: slideInUp 0.6s ease-out forwards;
        }
        
        .menu button:nth-child(2) { animation-delay: 0.1s; }
        .menu button:nth-child(3) { animation-delay: 0.2s; }
        .menu button:nth-child(4) { animation-delay: 0.3s; }
        .menu button:nth-child(5) { animation-delay: 0.4s; }
        .menu button:nth-child(6) { animation-delay: 0.5s; }
        
        .notification {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0);
            background: linear-gradient(135deg, #ffd700, #ffed4e);
            color: #333;
            padding: 20px 30px;
            border-radius: 15px;
            font-weight: bold;
            font-size: 18px;
            box-shadow: 0 10px 30px rgba(255,215,0,0.4);
            z-index: 2000;
            animation: notificationPop 2s ease-out;
            max-width: 95vw;
            text-align: center;
        }
        
        @keyframes notificationPop {
            0% { transform: translate(-50%, -50%) scale(0) rotate(-10deg); }
            50% { transform: translate(-50%, -50%) scale(1.1) rotate(5deg); }
            100% { transform: translate(-50%, -50%) scale(1) rotate(0deg); }
        }
        
        .theme-toggle, .sound-toggle {
            position: fixed;
            right: 20px;
            background: rgba(255,255,255,0.2);
            border: none;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            cursor: pointer;
            font-size: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
            z-index: 100;
        }
        
        .theme-toggle {
            top: 20px;
        }
        
        .sound-toggle {
            top: 80px;
            font-size: 20px;
        }
        
        .theme-toggle:hover {
            background: rgba(255,255,255,0.3);
            transform: rotate(180deg);
        }
        
        .sound-toggle:hover {
            background: rgba(255,255,255,0.3);
            transform: scale(1.1);
        }
        
        .progress-bar {
            position: fixed;
            top: 0;
            left: 0;
            width: 0%;
            height: 4px;
            background: linear-gradient(90deg, #4ade80, #22c55e);
            transition: width 0.3s ease;
            z-index: 1001;
        }
        
        .difficulty-indicator {
            display: inline-block;
            padding: 3px 8px;
            border-radius: 6px;
            font-size: 12px;
            font-weight: bold;
            margin-left: 5px;
            text-transform: uppercase;
        }
        
        .diff-easy { background: linear-gradient(135deg, #10b981, #059669); color: white; }
        .diff-medium { background: linear-gradient(135deg, #f59e0b, #d97706); color: white; }
        .diff-hard { background: linear-gradient(135deg, #ef4444, #dc2626); color: white; }
        .diff-expert { background: linear-gradient(135deg, #7c3aed, #6d28d9); color: white; }
        
        /* Deadlock analysis styles */
        .deadlock-analysis {
            background: rgba(239, 68, 68, 0.1);
            border: 1px solid rgba(239, 68, 68, 0.3);
            border-radius: 8px;
            padding: 12px;
            margin: 10px 0;
        }
        
        .analysis-item {
            margin: 8px 0;
            font-size: 13px;
        }
        
        .analysis-item.suggestion {
            color: #a78bfa;
            font-style: italic;
            background: rgba(167, 139, 250, 0.1);
            padding: 6px;
            border-radius: 4px;
        }
        
        /* Accessibility improvements */
        @media (prefers-reduced-motion: reduce) {
            *, *::before, *::after {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
        }
        
        @media (max-width: 768px) {
            body {
                padding: 10px;
            }
            
            .game-header {
                font-size: 14px;
                gap: 5px;
            }
            
            button {
                padding: 6px 12px;
                font-size: 12px;
            }
            
            .controls {
                gap: 5px;
            }
            
            #gameCanvas {
                border-width: 2px;
                border-radius: 10px;
            }
            
            .theme-toggle, .sound-toggle {
                width: 40px;
                height: 40px;
                font-size: 18px;
            }
            
            .sound-toggle {
                top: 70px;
            }
            
            .menu {
                padding: 20px;
            }
            
            .stat-item {
                min-width: 60px;
                padding: 6px 8px;
            }
            
            /* Mobile-friendly AI Analysis */
            .hint-notification {
                min-width: auto !important;
                max-width: 98vw !important;
                padding: 15px 35px 15px 15px !important;
                font-size: 12px !important;
            }
        }
        
        .btn-orange:hover:not(:disabled) {
            background: linear-gradient(145deg, #ea580c, #dc2626);
            transform: translateY(-2px);
        }
    </style>
</head>
<body>
    <button class="theme-toggle" onclick="safeGameCall('ui.toggleTheme')" title="Toggle theme" aria-label="Toggle color theme">🌓</button>
    <button class="sound-toggle" onclick="safeGameCall('ui.toggleSound')" title="Toggle sound" aria-label="Toggle sound effects">🔊</button>
    <div class="progress-bar" id="progressBar"></div>
    
    <div id="menu" class="menu">
        <h1>🃏 Klondike Solitaire</h1>
        <div style="margin-bottom: 20px; font-size: 14px; color: #a78bfa;">
            Enhanced with AI/Machine Learning 🧠
        </div>
        <button class="btn-green" onclick="game.ui.showDailyChallenge()">🏆 Daily Challenge</button>
        <button class="btn-blue" onclick="game.startGame(1)">🎯 Draw 1 Card</button>
        <button class="btn-blue" onclick="game.startGame(3)">🎮 Draw 3 Cards</button>
        <button class="btn-purple" onclick="game.ui.showSettings()">⚙️ Settings</button>
        <button class="btn-yellow" onclick="game.ui.showStats()">📊 Statistics</button>
        <button class="btn-red" onclick="game.ui.showAchievements()">🏅 Achievements</button>
        
        <div style="margin-top: 30px; padding-top: 20px; border-top: 1px solid rgba(255,255,255,0.2); font-size: 12px; opacity: 0.7; line-height: 1.4;">
            <strong>🧠 AI Features:</strong><br>
            • Neural network-powered move analysis<br>
            • Intelligent game state evaluation<br>
            • Adaptive difficulty recommendations<br>
            • Works on all devices (CPU-optimized)<br>
            • Learning from your gameplay patterns
        </div>
    </div>
    
    <div id="gameArea" style="display: none;">
        <div class="game-header">
            <div class="stats">
                <div class="stat-item">
                    <div class="stat-label">Moves</div>
                    <div class="stat-value" id="moves">0</div>
                </div>
                <div class="stat-item">
                    <div class="stat-label">Time</div>
                    <div class="stat-value" id="time">0:00</div>
                </div>
                <div class="stat-item" id="scoreDisplay" style="display: none;">
                    <div class="stat-label">Score</div>
                    <div class="stat-value" id="score">0</div>
                </div>
                <div class="stat-item" id="winProbDisplay" style="display: none;">
                    <div class="stat-label">Win %</div>
                    <div class="stat-value" id="winProb">0%</div>
                </div>
            </div>
            <div class="controls">
                <button class="btn-blue" onclick="safeGameCall('newGame')" title="Start new game (N)" aria-label="Start new game">🎲 New Game</button>
                <button class="btn-yellow" id="undoBtn" onclick="safeGameCall('undo')" title="Undo last move (U)" aria-label="Undo last move">↶ Undo</button>
                <button class="btn-orange" id="redoBtn" onclick="safeGameCall('redo')" title="Redo last undone move (R)" aria-label="Redo last undone move">↷ Redo</button>
                <button class="btn-purple" onclick="safeGameCall('ai.showHint')" title="Show AI hint (H)" aria-label="Show AI move hint">🧠 AI Hint</button>
                <button class="btn-orange" onclick="safeGameCall('ui.showMLAnalysis')" title="Show ML analysis" aria-label="Show machine learning analysis">📊 AI Analysis</button>
                <button class="btn-green" onclick="safeGameCall('storage.quickSave')" title="Quick save (S)" aria-label="Quick save game">💾 Save</button>
            </div>
        </div>
        <canvas id="gameCanvas" width="1000" height="600" role="application" aria-label="Klondike Solitaire Game Board" tabindex="0"></canvas>
    </div>
    
    <!-- Additional menu screens -->
    <div id="dailyChallenge" class="menu" style="display: none;">
        <h1>🏆 Daily Challenge</h1>
        <div id="challengeInfo" style="margin-bottom: 20px; font-size: 16px; line-height: 1.5;"></div>
        <button class="btn-green" id="playDailyBtn" onclick="safeGameCall('startDailyChallenge')">Play Today's Challenge</button>
        <button class="btn-blue" onclick="safeGameCall('ui.backToMainMenu')">← Back to Menu</button>
    </div>
    
    <div id="settings" class="menu" style="display: none;">
        <h1>⚙️ Settings</h1>
        <div style="text-align: left; max-width: 300px; margin: 0 auto;">
            <div style="margin-bottom: 20px;">
                <label style="display: block; margin-bottom: 10px; font-weight: bold;" for="difficultySelect">Difficulty Level:</label>
                <select id="difficultySelect" onchange="safeGameCall('settings.updateDifficulty')" style="width: 100%; padding: 8px; border-radius: 6px; border: 2px solid #374151; font-size: 16px; color: #333;">
                    <option value="easy">Easy - Draw 1</option>
                    <option value="medium">Medium - Draw 3</option>
                    <option value="hard">Hard - Draw 3, Vegas Scoring</option>
                </select>
            </div>
            
            <div style="margin-bottom: 20px;">
                <label style="display: flex; align-items: center; cursor: pointer;">
                    <input type="checkbox" id="autoMoveToFoundation" onchange="safeGameCall('settings.updateAutoMove')" style="margin-right: 10px; transform: scale(1.2);">
                    <span>Auto-move cards to foundation</span>
                </label>
            </div>
            
            <div style="margin-bottom: 20px;">
                <label style="display: flex; align-items: center; cursor: pointer;">
                    <input type="checkbox" id="showMoveHints" onchange="safeGameCall('settings.updateShowHints')" style="margin-right: 10px; transform: scale(1.2);">
                    <span>Show valid move hints</span>
                </label>
            </div>
            
            <div style="margin-bottom: 20px;">
                <label style="display: flex; align-items: center; cursor: pointer;">
                    <input type="checkbox" id="enableMLAnalysis" onchange="safeGameCall('settings.updateMLAnalysis')" style="margin-right: 10px; transform: scale(1.2);">
                    <span>Enable AI/ML analysis 🧠</span>
                </label>
            </div>
            
            <div style="margin-bottom: 20px;">
                <label style="display: flex; align-items: center; cursor: pointer;">
                    <input type="checkbox" id="adaptiveDifficulty" onchange="safeGameCall('settings.updateAdaptiveDifficulty')" style="margin-right: 10px; transform: scale(1.2);">
                    <span>Adaptive difficulty (AI-powered)</span>
                </label>
            </div>
        </div>
        
        <button class="btn-blue" onclick="safeGameCall('ui.backToMainMenu')">← Back to Menu</button>
        <button class="btn-orange" onclick="safeGameCall('settings.resetSettings')">Reset to Defaults</button>
    </div>
    
    <div id="stats" class="menu" style="display: none;">
        <h1>📊 Statistics</h1>
        <div id="statsContent" style="text-align: left; max-width: 400px; margin: 0 auto; font-size: 16px; line-height: 1.6;"></div>
        <button class="btn-blue" onclick="safeGameCall('ui.backToMainMenu')">← Back to Menu</button>
        <button class="btn-yellow" onclick="safeGameCall('stats.resetStats')">Reset Statistics</button>
    </div>
    
    <div id="achievements" class="menu" style="display: none;">
        <h1>🏅 Achievements</h1>
        <div id="achievementsList" style="text-align: left; max-width: 500px; margin: 0 auto; font-size: 16px;"></div>
        <button class="btn-blue" onclick="safeGameCall('ui.backToMainMenu')">← Back to Menu</button>
    </div>

    <script>
        'use strict';

        // Main game class
        class KlondikeSolitaire {
            constructor() {
                this.constants = new GameConstants();
                this.storage = new StorageManager();
                this.memory = new MemoryManager(); // Memory optimization system
                this.settings = new SettingsManager(this);
                this.stats = new StatisticsManager(this);
                this.achievements = new AchievementManager(this);
                this.sound = new SoundManager(this);
                this.ui = new UIManager(this);
                this.cards = new CardManager(this);
                this.input = new InputManager(this);
                this.renderer = new RenderEngine(this);
                this.rules = new GameRules(this);
                this.state = new GameState(this);
                this.ai = new AIHintSystem(this);
                this.daily = new DailyChallenge(this);
                this.ml = new MLManager(this);
                this.timer = null;
                this.gameWon = false;
                this.currentGameMode = 'standard';
                this.currentDifficulty = 'medium';
                this.gameHistory = [];
                this.redoHistory = [];
                this.haptics = HapticManager;
            }
            
            undo() {
                if (!this.gameHistory || this.gameHistory.length === 0) {
                    console.log('No moves to undo');
                    return;
                }
                
                const prevState = this.gameHistory.pop();
                if (!prevState) return;
                
                // Save current state to redo history before undoing
                this.redoHistory.push({
                    stock: this.state.stock.map(card => ({ ...card })),
                    waste: this.state.waste.map(card => ({ ...card })),
                    tableau: this.state.tableau.map(pile => pile.map(card => ({ ...card }))),
                    foundations: Object.fromEntries(
                        Object.entries(this.state.foundations).map(([suit, pile]) => 
                            [suit, pile.map(card => ({ ...card }))]
                        )
                    ),
                    gameStats: { ...this.state.gameStats }
                });
                
                // Restore previous state
                this.state.stock = prevState.stock;
                this.state.waste = prevState.waste;
                this.state.tableau = prevState.tableau;
                this.state.foundations = prevState.foundations;
                this.state.gameStats = { ...prevState.gameStats };
                this.state.hintCardId = null;
                this.state.hoveredCard = null;
                this.input.resetDragState();
                
                this.ui.updateUI();
                this.renderer.render();
            }
            
            startGame(drawMode) {
                try {
                    this.currentGameMode = 'normal';
                    this.state.drawMode = drawMode;
                    this.currentDifficulty = this.settings.data.difficulty;
                    
                    this.ui.hideAllMenus();
                    this.ui.showElement('gameArea');
                    this.input.initCanvas();
                    this.state.initializeGame();
                } catch (error) {
                    console.error('Error starting game:', error);
                }
            }
            
            startDailyChallenge() {
                try {
                    this.currentGameMode = 'daily';
                    const difficulty = this.daily.getDailyDifficulty();
                    const diffSettings = this.daily.getDifficultySettings(difficulty);
                    
                    this.state.drawMode = diffSettings.drawMode;
                    this.settings.data.scoringMode = diffSettings.scoringMode;
                    this.currentDifficulty = difficulty;
                    
                    this.ui.hideElement('dailyChallenge');
                    this.ui.showElement('gameArea');
                    this.input.initCanvas();
                    this.state.initializeGame();
                } catch (error) {
                    console.error('Error starting daily challenge:', error);
                }
            }
            
            newGame() {
                try {
                    if (confirm('Start a new game? Current progress will be lost.')) {
                        this.state.resetAllGameState();
                        this.state.initializeGame();
                    }
                } catch (error) {
                    console.error('Error starting new game:', error);
                }
            }
            
            redo() {
                if (!this.redoHistory || this.redoHistory.length === 0) {
                    console.log('No moves to redo');
                    return;
                }
                
                const nextState = this.redoHistory.pop();
                if (!nextState) return;
                
                // Save current state to undo history before redoing
                this.state.saveGameState();
                
                // Restore next state
                this.state.stock = nextState.stock;
                this.state.waste = nextState.waste;
                this.state.tableau = nextState.tableau;
                this.state.foundations = nextState.foundations;
                this.state.gameStats = { ...nextState.gameStats };
                this.state.hintCardId = null;
                this.state.hoveredCard = null;
                this.input.resetDragState();
                
                this.ui.updateUI();
                this.renderer.render();
            }
            
            cleanup() {
                try {
                    this.input.cleanup();
                    if (this.timer) clearInterval(this.timer);
                    if (this.ml && !this.ml.isDisposed) {
                        this.ml.dispose();
                    }
                } catch (error) {
                    console.error('Cleanup error:', error);
                }
            }
        }

        // Game constants
        class GameConstants {
            constructor() {
                this.SUITS = ['♠', '♥', '♦', '♣'];
                this.RED_SUITS = new Set(['♥', '♦']);
                this.RANKS = ['A','2','3','4','5','6','7','8','9','10','J','Q','K'];
                this.CARD_WIDTH = 80;
                this.CARD_HEIGHT = 120;
                this.FACE_DOWN_OFFSET = 8;
                this.FACE_UP_OFFSET = 20;
                this.WASTE_CARD_OFFSET = 25;
                this.MAX_HISTORY_SIZE = 50;
            }
        }

        // Storage manager
        class StorageManager {
            constructor() {
                this.available = this.checkStorageAvailability();
            }
            
            checkStorageAvailability() {
                try {
                    const test = '__storage_test__';
                    localStorage.setItem(test, test);
                    localStorage.removeItem(test);
                    return true;
                } catch (e) {
                    return false;
                }
            }
            
            set(key, value) {
                if (!this.available) return false;
                try {
                    localStorage.setItem(key, JSON.stringify(value));
                    return true;
                } catch (e) {
                    console.warn('Storage quota exceeded:', e);
                    return false;
                }
            }
            
            get(key) {
                if (!this.available) return null;
                try {
                    const item = localStorage.getItem(key);
                    return item ? JSON.parse(item) : null;
                } catch (e) {
                    console.warn('Storage parse error:', e);
                    return null;
                }
            }
            
            quickSave() {
                try {
                    game.state.saveToLocalStorage();
                    game.sound.play('cardPlace');
                    game.ui.showNotification('💾 Game Saved!', 'success');
                } catch (error) {
                    console.error('Quick save error:', error);
                }
            }
        }

        // Settings manager
        class SettingsManager {
            constructor(gameInstance) {
                this.game = gameInstance;
                this.data = this.getDefaultSettings();
            }
            
            getDefaultSettings() {
                return {
                    difficulty: 'medium',
                    autoMoveToFoundation: true,
                    showMoveHints: true,
                    enableMLAnalysis: true,
                    adaptiveDifficulty: false,
                    drawMode: 3,
                    scoringMode: 'standard',
                    theme: 'green',
                    soundEnabled: true
                };
            }
            
            loadSettings() {
                try {
                    const saved = this.game.storage.get('klondike_settings');
                    if (saved) {
                        this.data = { ...this.data, ...saved };
                    }
                    this.applySettings();
                } catch (error) {
                    console.error('Error loading settings:', error);
                    this.applySettings();
                }
            }
            
            saveSettings() {
                try {
                    this.game.storage.set('klondike_settings', this.data);
                } catch (error) {
                    console.error('Error saving settings:', error);
                }
            }
            
            applySettings() {
                if (this.game.currentGameMode === 'normal') {
                    const diffSettings = this.game.daily.getDifficultySettings(this.data.difficulty);
                    this.data.drawMode = diffSettings.drawMode;
                    this.data.scoringMode = diffSettings.scoringMode;
                }
            }
            
            updateDifficulty() {
                const select = document.getElementById('difficultySelect');
                this.data.difficulty = select.value;
                this.applySettings();
                this.saveSettings();
            }
            
            updateAutoMove() {
                const checkbox = document.getElementById('autoMoveToFoundation');
                this.data.autoMoveToFoundation = checkbox.checked;
                this.saveSettings();
            }
            
            updateShowHints() {
                const checkbox = document.getElementById('showMoveHints');
                this.data.showMoveHints = checkbox.checked;
                this.saveSettings();
            }
            
            updateMLAnalysis() {
                const checkbox = document.getElementById('enableMLAnalysis');
                this.data.enableMLAnalysis = checkbox.checked;
                this.saveSettings();
                
                if (this.data.enableMLAnalysis) {
                    this.game.ui.showNotification('🧠 AI analysis enabled! Enhanced hints and game analysis now available.', 'info', 3000);
                } else {
                    this.game.ui.showNotification('🧠 AI analysis disabled. Using basic heuristics only.', 'info', 2000);
                }
            }
            
            updateAdaptiveDifficulty() {
                const checkbox = document.getElementById('adaptiveDifficulty');
                this.data.adaptiveDifficulty = checkbox.checked;
                this.saveSettings();
                
                if (this.data.adaptiveDifficulty) {
                    this.game.ui.showNotification('🎯 Adaptive difficulty enabled! AI will suggest optimal challenge level.', 'info', 3000);
                } else {
                    this.game.ui.showNotification('🎯 Adaptive difficulty disabled.', 'info', 2000);
                }
            }
            
            resetSettings() {
                if (confirm('Reset all settings to defaults?')) {
                    this.data = this.getDefaultSettings();
                    this.applySettings();
                    this.game.ui.updateSettingsUI();
                    this.saveSettings();
                }
            }
        }

        // Statistics manager
        class StatisticsManager {
            constructor(gameInstance) {
                this.game = gameInstance;
                this.data = this.getDefaultStats();
            }
            
            getDefaultStats() {
                return {
                    gamesPlayed: 0,
                    gamesWon: 0,
                    totalTime: 0,
                    totalMoves: 0,
                    bestTime: null,
                    bestScore: 0,
                    currentStreak: 0,
                    longestStreak: 0,
                    dailyChallenges: {}
                };
            }
            
            loadStatistics() {
                try {
                    const saved = this.game.storage.get('klondike_statistics');
                    if (saved) {
                        this.data = { ...this.data, ...saved };
                    }
                } catch (error) {
                    console.error('Error loading statistics:', error);
                }
            }
            
            saveStatistics() {
                try {
                    this.game.storage.set('klondike_statistics', this.data);
                } catch (error) {
                    console.error('Error saving statistics:', error);
                }
            }
            
            updateGameStatistics(won) {
                try {
                    if (won) {
                        this.data.gamesWon++;
                        this.data.totalTime += this.game.state.gameStats.time;
                        this.data.totalMoves += this.game.state.gameStats.moves;
                        this.data.currentStreak++;
                        this.data.longestStreak = Math.max(this.data.longestStreak, this.data.currentStreak);
                        
                        if (!this.data.bestTime || this.game.state.gameStats.time < this.data.bestTime) {
                            this.data.bestTime = this.game.state.gameStats.time;
                        }
                        if (this.game.state.gameStats.score > this.data.bestScore) {
                            this.data.bestScore = this.game.state.gameStats.score;
                        }
                    } else {
                        this.data.currentStreak = 0;
                    }
                    
                    if (this.game.currentGameMode === 'daily' && won) {
                        const today = new Date().toISOString().split('T')[0];
                        this.data.dailyChallenges[today] = {
                            completed: true,
                            score: this.game.state.gameStats.score,
                            time: this.game.state.gameStats.time,
                            moves: this.game.state.gameStats.moves
                        };
                    }
                    
                    this.saveStatistics();
                    
                    if (won) {
                        setTimeout(() => {
                            if (this.game.achievements && typeof this.game.achievements.checkAchievements === 'function') {
                                this.game.achievements.checkAchievements();
                            } else {
                                console.warn('Achievements system not available');
                            }
                        }, 1000);
                    }
                } catch (error) {
                    console.error('Error updating statistics:', error);
                }
            }
            
            resetStats() {
                if (confirm('Reset all statistics? This cannot be undone.')) {
                    this.data = this.getDefaultStats();
                    this.saveStatistics();
                    this.game.ui.updateStatsUI();
                }
            }
        }

        // Achievement manager
        class AchievementManager {
            constructor(gameInstance) {
                this.game = gameInstance;
                this.achievements = {
                    firstWin: { name: "First Victory", description: "Win your first game", unlocked: false, icon: "🎉" },
                    speedDemon: { name: "Speed Demon", description: "Win a game in under 3 minutes", unlocked: false, icon: "⚡" },
                    perfectGame: { name: "Perfect Game", description: "Win without using undo", unlocked: false, icon: "💎" },
                    streakMaster: { name: "Streak Master", description: "Win 5 games in a row", unlocked: false, icon: "🔥" },
                    cardShark: { name: "Card Shark", description: "Win 100 games", unlocked: false, icon: "🦈" }
                };
            }
            
            loadAchievements() {
                try {
                    const saved = this.game.storage.get('klondike_achievements');
                    if (saved) {
                        Object.keys(this.achievements).forEach(key => {
                            if (saved[key]) {
                                this.achievements[key] = { ...this.achievements[key], ...saved[key] };
                            }
                        });
                    }
                } catch (error) {
                    console.error('Error loading achievements:', error);
                }
            }
            
            saveAchievements() {
                try {
                    this.game.storage.set('klondike_achievements', this.achievements);
                } catch (error) {
                    console.error('Error saving achievements:', error);
                }
            }
            
            checkAchievements() {
                try {
                    const stats = this.game.stats.data;
                    
                    if (!this.achievements.firstWin.unlocked && stats.gamesWon >= 1) {
                        this.unlockAchievement('firstWin');
                    }
                    
                    if (!this.achievements.speedDemon.unlocked && 
                        this.game.state.gameStats.time <= 180 && this.game.gameWon) {
                        this.unlockAchievement('speedDemon');
                    }
                    
                    if (!this.achievements.perfectGame.unlocked && 
                        this.game.gameWon && 
                        this.game.state.gameHistory && this.game.state.gameHistory.length === 0) {
                        this.unlockAchievement('perfectGame');
                    }
                    
                    if (!this.achievements.streakMaster.unlocked && stats.currentStreak >= 5) {
                        this.unlockAchievement('streakMaster');
                    }
                    
                    if (!this.achievements.cardShark.unlocked && stats.gamesWon >= 100) {
                        this.unlockAchievement('cardShark');
                    }
                } catch (error) {
                    console.error('Error checking achievements:', error);
                }
            }
            
            unlockAchievement(achievementId) {
                try {
                    this.achievements[achievementId].unlocked = true;
                    this.game.ui.showAchievementNotification(achievementId);
                    this.game.sound.play('achievement');
                    this.saveAchievements();
                } catch (error) {
                    console.error('Error unlocking achievement:', error);
                }
            }
        }

        // Daily challenge system
        class DailyChallenge {
            constructor(gameInstance) {
                this.game = gameInstance;
                this.difficulties = ['easy', 'medium', 'hard'];
            }
            
            getDailyDifficulty() {
                const dayOfWeek = new Date().getDay();
                if (dayOfWeek === 0 || dayOfWeek === 6) return 'easy';
                if (dayOfWeek <= 2) return 'medium';
                return 'hard';
            }
            
            getDifficultySettings(difficulty) {
                const settings = {
                    easy: { drawMode: 1, scoringMode: 'standard' },
                    medium: { drawMode: 3, scoringMode: 'standard' },
                    hard: { drawMode: 3, scoringMode: 'vegas' }
                };
                return settings[difficulty] || settings.medium;
            }
        }

        // Sound manager
        class SoundManager {
            constructor(gameInstance) {
                this.game = gameInstance;
                this.audioContext = null;
                this.sounds = {
                    cardFlip: () => this.playTone(400, 100),
                    cardPlace: () => this.playTone(600, 150),
                    victory: () => this.playVictorySound(),
                    achievement: () => this.playAchievementSound(),
                    error: () => this.playTone(200, 200)
                };
                this.initAudioContext();
            }
            
            initAudioContext() {
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                } catch (e) {
                    console.warn('Web Audio API not supported');
                }
            }
            
            play(soundName) {
                if (!this.game.settings.data.soundEnabled || !this.sounds[soundName]) return;
                try {
                    if (this.audioContext && this.audioContext.state === 'suspended') {
                        this.audioContext.resume();
                    }
                    this.sounds[soundName]();
                } catch (error) {
                    console.warn('Sound playback error:', error);
                }
            }
            
            playTone(frequency, duration) {
                if (!this.audioContext) return;
                try {
                    const oscillator = this.audioContext.createOscillator();
                    const gainNode = this.audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(this.audioContext.destination);
                    
                    oscillator.frequency.value = frequency;
                    oscillator.type = 'sine';
                    
                    gainNode.gain.setValueAtTime(0.1, this.audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + duration / 1000);
                    
                    oscillator.start(this.audioContext.currentTime);
                    oscillator.stop(this.audioContext.currentTime + duration / 1000);
                } catch (error) {
                    console.warn('Tone generation error:', error);
                }
            }
            
            playVictorySound() {
                const notes = [523, 659, 784, 1047];
                notes.forEach((note, index) => {
                    setTimeout(() => this.playTone(note, 200), index * 150);
                });
            }
            
            playAchievementSound() {
                const notes = [784, 1047, 1319];
                notes.forEach((note, index) => {
                    setTimeout(() => this.playTone(note, 300), index * 100);
                });
            }
        }

        // UI manager
        class UIManager {
            constructor(gameInstance) {
                this.game = gameInstance;
                this.currentTheme = 'green';
            }
            
            showElement(id) {
                const element = document.getElementById(id);
                if (element) element.style.display = 'block';
            }
            
            hideElement(id) {
                const element = document.getElementById(id);
                if (element) element.style.display = 'none';
            }
            
            hideAllMenus() {
                ['menu', 'achievements', 'dailyChallenge', 'settings', 'stats'].forEach(id => {
                    this.hideElement(id);
                });
            }
            
            showNotification(message, type = 'info', duration = 2000) {
                try {
                    const notification = document.createElement('div');
                    
                    // Create close button
                    const closeButton = document.createElement('button');
                    closeButton.innerHTML = '×';
                    closeButton.style.cssText = `
                        position: absolute;
                        top: 8px;
                        right: 8px;
                        background: rgba(255, 255, 255, 0.2);
                        border: none;
                        border-radius: 50%;
                        width: 24px;
                        height: 24px;
                        color: inherit;
                        font-size: 16px;
                        font-weight: bold;
                        cursor: pointer;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        transition: background-color 0.2s ease;
                        z-index: 1;
                    `;
                    
                    closeButton.addEventListener('mouseenter', () => {
                        closeButton.style.background = 'rgba(255, 255, 255, 0.3)';
                    });
                    
                    closeButton.addEventListener('mouseleave', () => {
                        closeButton.style.background = 'rgba(255, 255, 255, 0.2)';
                    });
                    
                    if (type === 'error') {
                        notification.className = 'error-message';
                        notification.style.cssText = `
                            position: fixed;
                            top: 20px;
                            left: 50%;
                            transform: translateX(-50%) scale(1);
                            background: linear-gradient(135deg, #ef4444, #dc2626);
                            color: white;
                            padding: 15px 35px 15px 25px;
                            border-radius: 10px;
                            font-weight: bold;
                            z-index: 2000;
                            box-shadow: 0 10px 25px rgba(239,68,68,0.4);
                            max-width: 90vw;
                            text-align: center;
                            animation: shake 0.5s ease-in-out;
                        `;
                    } else if (type === 'hint') {
                        notification.className = 'hint-notification';
                        notification.style.cssText = `
                            position: fixed;
                            top: 50%;
                            left: 50%;
                            transform: translate(-50%, -50%) scale(1);
                            background: linear-gradient(135deg, #1f2937, #374151);
                            color: white;
                            padding: 20px 40px 20px 20px;
                            border-radius: 15px;
                            font-weight: normal;
                            font-size: 14px;
                            box-shadow: 0 10px 30px rgba(0,0,0,0.4);
                            z-index: 2000;
                            max-width: 95vw;
                            min-width: 700px;
                            border: 2px solid #4ade80;
                            animation: notificationPop 0.5s ease-out;
                        `;
                    } else {
                        notification.className = 'notification';
                        notification.style.cssText = `
                            position: fixed;
                            top: 50%;
                            left: 50%;
                            transform: translate(-50%, -50%) scale(1);
                            background: linear-gradient(135deg, #ffd700, #ffed4e);
                            color: #333;
                            padding: 20px 40px 20px 30px;
                            border-radius: 15px;
                            font-weight: bold;
                            font-size: 18px;
                            box-shadow: 0 10px 30px rgba(255,215,0,0.4);
                            z-index: 2000;
                            max-width: 90vw;
                            text-align: center;
                            animation: notificationPop 0.5s ease-out;
                        `;
                    }
                    
                    // Create content wrapper
                    const contentDiv = document.createElement('div');
                    contentDiv.innerHTML = message;
                    
                    // Function to close notification
                    const closeNotification = () => {
                        try {
                            if (notification && notification.parentNode) {
                                notification.style.transform = notification.style.transform.replace('scale(1)', 'scale(0)');
                                setTimeout(() => {
                                    if (notification && notification.parentNode) {
                                        document.body.removeChild(notification);
                                    }
                                }, 300);
                            }
                        } catch (removeError) {
                            console.warn('Error removing notification:', removeError);
                        }
                    };
                    
                    closeButton.addEventListener('click', closeNotification);
                    
                    // Assemble notification
                    notification.appendChild(closeButton);
                    notification.appendChild(contentDiv);
                    document.body.appendChild(notification);
                    notification.offsetHeight;
                    
                    // Auto-close timer
                    const autoCloseTimer = setTimeout(closeNotification, duration);
                    
                    // Cancel auto-close if user closes manually
                    closeButton.addEventListener('click', () => {
                        clearTimeout(autoCloseTimer);
                    });
                    
                } catch (error) {
                    console.error('Error showing notification:', error);
                    alert(message.replace(/<[^>]*>/g, ''));
                }
            }
            
            showAchievementNotification(achievementId) {
                const achievement = this.game.achievements.achievements[achievementId];
                this.showNotification(`
                    <div style="font-size: 24px; margin-bottom: 10px;">${achievement.icon}</div>
                    <div style="font-size: 18px; font-weight: bold;">Achievement Unlocked!</div>
                    <div style="font-size: 16px;">${achievement.name}</div>
                    <div style="font-size: 14px; opacity: 0.8;">${achievement.description}</div>
                `, 'achievement', 4000);
            }
            
            toggleTheme() {
                const themes = ['green', 'blue', 'dark', 'light'];
                const currentIndex = themes.indexOf(this.currentTheme);
                this.currentTheme = themes[(currentIndex + 1) % themes.length];
                this.game.settings.data.theme = this.currentTheme;
                this.applyTheme();
                this.game.settings.saveSettings();
                this.game.sound.play('cardFlip');
            }
            
            applyTheme() {
                this.currentTheme = this.game.settings.data.theme;
                const body = document.body;
                
                // Remove all theme classes
                body.className = '';
                
                switch(this.currentTheme) {
                    case 'dark':
                        body.classList.add('dark-theme');
                        document.querySelector('.theme-toggle').textContent = '🌙';
                        break;
                    case 'light':
                        body.classList.add('light-theme');
                        document.querySelector('.theme-toggle').textContent = '☀️';
                        break;
                    case 'blue':
                        body.classList.add('blue-theme');
                        document.querySelector('.theme-toggle').textContent = '🌊';
                        break;
                    default:
                        document.querySelector('.theme-toggle').textContent = '🌓';
                        break;
                }
                
                this.currentTheme = this.game.settings.data.theme;
            }
            
            toggleSound() {
                this.game.settings.data.soundEnabled = !this.game.settings.data.soundEnabled;
                const soundBtn = document.querySelector('.sound-toggle');
                soundBtn.textContent = this.game.settings.data.soundEnabled ? '🔊' : '🔇';
                this.game.settings.saveSettings();
                if (this.game.settings.data.soundEnabled) this.game.sound.play('cardPlace');
            }
            
            updateProgressBar() {
                const foundationCards = Object.values(this.game.state.foundations)
                    .reduce((sum, pile) => sum + pile.length, 0);
                const progress = (foundationCards / 52) * 100;
                
                const progressBar = document.getElementById('progressBar');
                if (progressBar) {
                    progressBar.style.width = `${progress}%`;
                }
            }
            
            updateWinProbability() {
                const winProbElement = document.getElementById('winProb');
                const winProbDisplay = document.getElementById('winProbDisplay');
                
                if (!winProbElement || !winProbDisplay) return;
                
                if (this.game.ml && this.game.ml.isInitialized) {
                    // Use ML analysis for win probability
                    this.game.ml.getGameAnalysis(this.game.state).then(analysis => {
                        if (analysis.winProbability) {
                            const prob = Math.round(analysis.winProbability * 100);
                            winProbElement.textContent = `${prob}%`;
                            winProbDisplay.style.display = 'block';
                        }
                    }).catch(err => {
                        console.warn('Error getting ML analysis for win probability:', err);
                    });
                } else {
                    // Basic heuristic calculation
                    const foundationCards = Object.values(this.game.state.foundations)
                        .reduce((sum, pile) => sum + pile.length, 0);
                    const foundationProgress = foundationCards / 52;
                    const faceUpCards = this.game.state.tableau.reduce((sum, pile) => 
                        sum + pile.filter(c => c.faceUp).length, 0);
                    const faceUpRatio = faceUpCards / 28;
                    const moves = this.game.ai.findAllPossibleMoves().length;
                    const movesFactor = Math.min(moves / 10, 1);
                    
                    const winProb = Math.min(
                        (foundationProgress * 0.5) + 
                        (faceUpRatio * 0.3) + 
                        (movesFactor * 0.2), 
                        0.95
                    );
                    const prob = Math.round(winProb * 100);
                    
                    winProbElement.textContent = `${prob}%`;
                    winProbDisplay.style.display = 'block';
                }
            }
            
            updateUI() {
                try {
                    document.getElementById('moves').textContent = this.game.state.gameStats.moves;
                    const minutes = Math.floor(this.game.state.gameStats.time / 60);
                    const seconds = this.game.state.gameStats.time % 60;
                    document.getElementById('time').textContent = 
                        `${minutes}:${seconds.toString().padStart(2, '0')}`;
                    document.getElementById('score').textContent = this.game.state.gameStats.score;
                    document.getElementById('undoBtn').disabled = this.game.gameHistory.length === 0;
                    document.getElementById('redoBtn').disabled = this.game.redoHistory.length === 0;
                    
                    this.updateProgressBar();
                    this.updateWinProbability();
                    
                    const scoreDisplay = document.getElementById('scoreDisplay');
                    if (this.game.state.gameStats.score !== 0 || 
                        this.game.settings.data.scoringMode === 'vegas' || 
                        this.game.currentGameMode === 'daily') {
                        scoreDisplay.style.display = 'block';
                    }
                    
                    this.game.state.checkWinCondition();
                } catch (error) {
                    console.error('Error updating UI:', error);
                }
            }
            
            showWinModal() {
                const minutes = Math.floor(this.game.state.gameStats.time / 60);
                const seconds = this.game.state.gameStats.time % 60;
                const timeStr = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                
                this.showNotification(`
                    <h2>🎉 Congratulations! 🎉</h2>
                    <p>You won in <strong>${this.game.state.gameStats.moves}</strong> moves and <strong>${timeStr}</strong>!</p>
                    <p>Final Score: <strong>${this.game.state.gameStats.score}</strong> points</p>
                    <button class="btn-green" onclick="if(window.game && game.ui) game.ui.backToMenu(); else location.reload();" style="margin-top: 15px; padding: 10px 20px;">Play Again</button>
                `, 'win', 10000);
                
                this.game.sound.play('victory');
            }
            
            showDeadlockModal() {
                const minutes = Math.floor(this.game.state.gameStats.time / 60);
                const seconds = this.game.state.gameStats.time % 60;
                const timeStr = `${minutes}:${seconds.toString().padStart(2, '0')}`;
                
                // Get deadlock analysis if available
                let analysisContent = '';
                if (this.game.ml && this.game.ml.lastDeadlockAnalysis) {
                    const analysis = this.game.ml.lastDeadlockAnalysis;
                    analysisContent = `
                        <div style="background: rgba(255,255,255,0.1); padding: 12px; border-radius: 8px; margin: 10px 0; text-align: left;">
                            <h4 style="margin: 0 0 8px 0; color: #fbbf24;">🔍 AI Analysis</h4>
                            <div style="margin-bottom: 6px;"><strong>Primary Cause:</strong> ${this.formatDeadlockCause(analysis.primaryCause)}</div>
                            <div style="color: #a78bfa; font-style: italic; font-size: 13px;">💡 ${analysis.suggestion}</div>
                            ${analysis.criticalMovePoint ? `<div style="font-size: 12px; color: #ef4444; margin-top: 4px;">⚠️ Critical point around move ${analysis.criticalMovePoint}</div>` : ''}
                            ${analysis.stockCycles > 2 ? `<div style="font-size: 12px; color: #f59e0b; margin-top: 4px;">🔄 Stock cycled ${analysis.stockCycles} times</div>` : ''}
                        </div>
                    `;
                }
                
                this.showNotification(`
                    <h2>🚫 Game Deadlocked</h2>
                    <p>No more moves are available. Your game has been recorded for AI learning.</p>
                    <div style="background: rgba(255,255,255,0.1); padding: 10px; border-radius: 8px; margin: 10px 0;">
                        <strong>Final Stats:</strong><br>
                        Time: ${timeStr} | Moves: ${this.game.state.gameStats.moves} | Score: ${this.game.state.gameStats.score}
                    </div>
                    ${analysisContent}
                    <button class="btn-green" onclick="if(window.game && game.ui) game.ui.backToMenu(); else location.reload();" style="margin-top: 15px; padding: 10px 20px;">New Game</button>
                `, 'error', 15000);
                
                console.log('🧠 Deadlock recorded for AI learning');
            }
            
            formatDeadlockCause(cause) {
                const causes = {
                    'excessive_stock_cycling': 'Too many stock cycles',
                    'suboptimal_mid_game_decisions': 'Poor mid-game decisions', 
                    'unfavorable_initial_deal': 'Challenging initial deal',
                    'analysis_error': 'Could not analyze'
                };
                return causes[cause] || cause;
            }
            
            showDailyChallenge() {
                this.hideElement('menu');
                this.showElement('dailyChallenge');
                this.updateDailyChallengeInfo();
            }
            
            showSettings() {
                this.hideElement('menu');
                this.showElement('settings');
                this.updateSettingsUI();
            }
            
            showStats() {
                this.hideElement('menu');
                this.showElement('stats');
                this.updateStatsUI();
            }
            
            showAchievements() {
                this.hideElement('menu');
                this.showElement('achievements');
                this.updateAchievementsUI();
            }
            
            backToMainMenu() {
                this.hideAllMenus();
                this.showElement('menu');
            }
            
            backToMenu() {
                this.hideElement('gameArea');
                
                if (this.game.currentGameMode === 'daily') {
                    this.showElement('dailyChallenge');
                    this.updateDailyChallengeInfo();
                } else {
                    this.showElement('menu');
                }
                
                this.game.cleanup();
                this.game.currentGameMode = 'normal';
                this.game.state.drawMode = null;
                this.game.input.resetDragState();
            }
            
            updateDailyChallengeInfo() {
                const today = new Date().toISOString().split('T')[0];
                const difficulty = this.game.daily.getDailyDifficulty();
                const isCompleted = this.game.stats.data.dailyChallenges[today]?.completed || false;
                
                document.getElementById('challengeInfo').innerHTML = `
                    <div style="background: rgba(255,255,255,0.1); padding: 15px; border-radius: 12px;">
                        <strong>Today's Challenge</strong>
                        <span class="difficulty-indicator diff-${difficulty}">${difficulty.toUpperCase()}</span>
                        <br><br>
                        <strong>Status:</strong> 
                        <span style="color: ${isCompleted ? '#10b981' : '#f59e0b'};">
                            ${isCompleted ? '✅ Completed' : '🎯 Available'}
                        </span>
                        ${isCompleted ? `<br><br><strong>Your Score:</strong> ${this.game.stats.data.dailyChallenges[today]?.score || 0}` : ''}
                    </div>
                `;
            }
            
            updateSettingsUI() {
                document.getElementById('difficultySelect').value = this.game.settings.data.difficulty;
                document.getElementById('autoMoveToFoundation').checked = this.game.settings.data.autoMoveToFoundation;
                document.getElementById('showMoveHints').checked = this.game.settings.data.showMoveHints;
                
                const enableMLCheckbox = document.getElementById('enableMLAnalysis');
                const adaptiveDifficultyCheckbox = document.getElementById('adaptiveDifficulty');
                
                if (enableMLCheckbox) {
                    enableMLCheckbox.checked = this.game.settings.data.enableMLAnalysis;
                }
                if (adaptiveDifficultyCheckbox) {
                    adaptiveDifficultyCheckbox.checked = this.game.settings.data.adaptiveDifficulty;
                }
            }
            
            updateStatsUI() {
                const stats = this.game.stats.data;
                const winRate = stats.gamesPlayed > 0 ? 
                    Math.round((stats.gamesWon / stats.gamesPlayed) * 100) : 0;
                const avgTime = stats.gamesWon > 0 ? 
                    Math.round(stats.totalTime / stats.gamesWon) : 0;
                const avgMoves = stats.gamesWon > 0 ? 
                    Math.round(stats.totalMoves / stats.gamesWon) : 0;
                
                document.getElementById('statsContent').innerHTML = `
                    <div style="background: rgba(255,255,255,0.1); padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                        <h3 style="margin-top: 0; color: #4ade80;">Overall Statistics</h3>
                        <strong>Games Won:</strong> ${stats.gamesWon} / ${stats.gamesPlayed} (${winRate}%)<br>
                        <strong>Current Streak:</strong> ${stats.currentStreak}<br>
                        <strong>Longest Streak:</strong> ${stats.longestStreak}<br>
                        <strong>Best Score:</strong> ${stats.bestScore}<br>
                        <strong>Best Time:</strong> ${stats.bestTime ? this.formatTime(stats.bestTime) : 'N/A'}<br>
                        <strong>Average Time:</strong> ${avgTime > 0 ? this.formatTime(avgTime) : 'N/A'}<br>
                        <strong>Average Moves:</strong> ${avgMoves || 'N/A'}
                    </div>
                `;
            }
            
            updateAchievementsUI() {
                const achievementsList = document.getElementById('achievementsList');
                let html = '';
                
                Object.entries(this.game.achievements.achievements).forEach(([id, achievement]) => {
                    const unlocked = achievement.unlocked;
                    html += `
                        <div style="display: flex; align-items: center; margin: 15px 0; padding: 15px; background: rgba(255,255,255,${unlocked ? '0.2' : '0.05'}); border-radius: 10px; ${unlocked ? '' : 'opacity: 0.6;'}">
                            <div style="font-size: 24px; margin-right: 15px;">${unlocked ? achievement.icon : '🔒'}</div>
                            <div>
                                <div style="font-weight: bold; margin-bottom: 5px;">${achievement.name}</div>
                                <div style="font-size: 14px; opacity: 0.8;">${achievement.description}</div>
                                ${unlocked ? '<div style="color: #4ade80; font-size: 12px; margin-top: 3px;">✅ Unlocked</div>' : ''}
                            </div>
                        </div>
                    `;
                });
                
                achievementsList.innerHTML = html;
            }
            
            formatTime(seconds) {
                const minutes = Math.floor(seconds / 60);
                const secs = seconds % 60;
                return `${minutes}:${secs.toString().padStart(2, '0')}`;
            }
            
            async showMLAnalysis() {
                try {
                    let analysis, moves;
                    let mlAvailable = false;
                    
                    if (this.game.ml && this.game.ml.isInitialized) {
                        try {
                            // Get comprehensive analysis from advanced AI
                            analysis = await this.game.ml.getGameAnalysis(this.game.state);
                            moves = this.game.ai.findAllPossibleMoves();
                            
                            // Evaluate moves with advanced AI
                            const evaluatedMoves = [];
                            for (const move of moves.slice(0, 5)) { // Analyze top 5 moves
                                const evaluation = await this.game.ml.evaluateMove(move, this.game.state);
                                evaluatedMoves.push(evaluation);
                            }
                            
                            moves = evaluatedMoves.sort((a, b) => b.aiScore - a.aiScore);
                            mlAvailable = true;
                        } catch (mlError) {
                            console.warn('Advanced ML analysis failed, using fallback:', mlError);
                        }
                    }
                    
                    if (!analysis) {
                        moves = this.game.ai.findAllPossibleMoves();
                        
                        const foundationCards = Object.values(this.game.state.foundations).reduce((sum, pile) => sum + pile.length, 0);
                        const foundationProgress = foundationCards / 52;
                        const faceUpCards = this.game.state.tableau.reduce((sum, pile) => 
                            sum + pile.filter(c => c.faceUp).length, 0);
                        const faceUpRatio = faceUpCards / 28;
                        
                        const winProb = Math.min((foundationProgress * 0.6) + (faceUpRatio * 0.3) + 0.1, 0.95);
                        
                        analysis = {
                            winProbability: winProb,
                            difficulty: winProb > 0.7 ? 'easy' : winProb > 0.5 ? 'medium' : winProb > 0.3 ? 'hard' : 'expert',
                            recommendation: winProb > 0.6 ? 'You\'re doing great! 🎯' : 
                                          winProb > 0.3 ? 'Stay focused and think ahead! 🤔' : 
                                          'This is challenging - consider your moves carefully! 😬',
                            stockRecommendation: { shouldDraw: true, reason: 'Standard progression' }
                        };
                    }
                    
                    // Prepare move analysis
                    let moveAnalysis = '';
                    if (moves && moves.length > 0) {
                        const top5 = moves.slice(0, 5);
                        moveAnalysis = top5.map((move, i) => {
                            let scoreDisplay = '';
                            if (move.aiScore !== undefined) {
                                scoreDisplay = `${Math.round(move.aiScore)}pts`;
                            } else {
                                scoreDisplay = `${Math.round((move.priority / 20) * 100)}%`;
                            }
                            
                            let confidence = '';
                            if (move.confidence !== undefined) {
                                confidence = ` (${Math.round(move.confidence * 100)}% confidence)`;
                            }
                            
                            let reasoning = '';
                            if (move.strategicReasoning && move.strategicReasoning.length > 0) {
                                reasoning = `<br><small style="opacity: 0.8;">• ${move.strategicReasoning[0]}</small>`;
                            }
                            
                            return `${i + 1}. ${move.description} - ${scoreDisplay}${confidence}${reasoning}`;
                        }).join('<br><br>');
                    } else {
                        moveAnalysis = 'No immediate moves available - check stock drawing recommendation';
                    }
                    
                    // Stock drawing analysis
                    let stockAnalysis = '';
                    if (analysis.stockRecommendation) {
                        const stock = analysis.stockRecommendation;
                        stockAnalysis = `
                            <div style="background: rgba(255,255,255,0.1); padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                                <strong>📚 Stock Drawing Strategy</strong><br>
                                <div style="margin-top: 8px; font-size: 13px; line-height: 1.4;">
                                    <span style="color: ${stock.shouldDraw ? '#4ade80' : '#f59e0b'}; font-weight: bold;">
                                        ${stock.shouldDraw ? '✅ Recommended: Draw from stock' : '⏸️ Wait: Focus on tableau moves first'}
                                    </span><br>
                                    <strong>Reason:</strong> ${stock.reason}<br>
                                    ${stock.upcomingCards ? `<strong>Next cards:</strong> ${stock.upcomingCards.join(', ')}<br>` : ''}
                                    ${stock.immediateUseCards ? `<strong>Immediately useful:</strong> ${stock.immediateUseCards} card(s)<br>` : ''}
                                    ${stock.valuableCards ? `<strong>High-value cards:</strong> ${stock.valuableCards} card(s)<br>` : ''}
                                    ${stock.drawValue ? `<strong>Draw value score:</strong> ${stock.drawValue}` : ''}
                                </div>
                            </div>
                        `;
                    }
                    
                    // Hidden card insights
                    let hiddenCardAnalysis = '';
                    if (analysis.hiddenCardInsights && analysis.hiddenCardInsights.insights.length > 0) {
                        const insights = analysis.hiddenCardInsights;
                        hiddenCardAnalysis = `
                            <div style="background: rgba(255,255,255,0.1); padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                                <strong>🔍 Complete Board Vision (Hidden Cards)</strong><br>
                                <div style="margin-top: 8px; font-size: 13px; line-height: 1.4;">
                                    <strong>Total hidden cards:</strong> ${insights.count}<br>
                                    <strong>Strategic value:</strong> ${insights.totalValue}<br><br>
                                    ${insights.insights.slice(0, 5).map(insight => `• ${insight}`).join('<br>')}
                                    ${insights.insights.length > 5 ? `<br>• ...and ${insights.insights.length - 5} more` : ''}
                                </div>
                            </div>
                        `;
                    }
                    
                    // Learning insights
                    let learningProgress = '';
                    if (analysis.learningInsights) {
                        const learning = analysis.learningInsights;
                        learningProgress = `
                            <div style="background: rgba(255,255,255,0.1); padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                                <strong>🧠 AI Learning Progress</strong><br>
                                <div style="margin-top: 8px; font-size: 13px; line-height: 1.4;">
                                    • Learning database: ${learning.totalLearningData} winning games<br>
                                    • Similar winning positions: ${learning.similarWinningGames}<br>
                                    • Historically successful moves available: ${learning.historicallySuccessfulMoves}<br>
                                    • Confidence boost from learning: +${Math.round(learning.confidenceBoost * 100)}%<br><br>
                                    ${learning.insights.length > 0 ? learning.insights.map(insight => `• ${insight}`).join('<br>') : '• Building learning database from your gameplay'}
                                </div>
                            </div>
                        `;
                    }
                    
                    // Strategic insights
                    let strategicInsights = '';
                    if (analysis.strategicInsights && analysis.strategicInsights.length > 0) {
                        strategicInsights = `
                            <div style="background: rgba(255,255,255,0.1); padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                                <strong>🎯 Strategic Insights</strong><br>
                                <div style="margin-top: 8px; font-size: 13px; line-height: 1.4;">
                                    ${analysis.strategicInsights.map(insight => `• ${insight}`).join('<br>')}
                                </div>
                            </div>
                        `;
                    }
                    
                    // Web AI insights (if available)
                    let webAIInsights = '';
                    if (analysis.webAIInsights) {
                        const webAI = analysis.webAIInsights;
                        webAIInsights = `
                            <div style="background: rgba(255,255,255,0.1); padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                                <strong>🌐 External AI Consultation</strong><br>
                                <div style="margin-top: 8px; font-size: 13px; line-height: 1.4;">
                                    <strong>Confidence:</strong> ${Math.round(webAI.confidence * 100)}%<br>
                                    <strong>Recommendation:</strong> ${webAI.recommendation}<br>
                                    <strong>Risk Assessment:</strong> ${webAI.riskAssessment}<br><br>
                                    ${webAI.strategicInsights.map(insight => `• ${insight}`).join('<br>')}
                                </div>
                            </div>
                        `;
                    }
                    
                    // Neural network weights (for advanced users)
                    let neuralWeights = '';
                    if (analysis.neuralWeights && mlAvailable) {
                        const weights = analysis.neuralWeights;
                        neuralWeights = `
                            <div style="background: rgba(255,255,255,0.05); padding: 10px; border-radius: 6px; margin-bottom: 15px;">
                                <strong>🧮 Neural Network Weights</strong><br>
                                <div style="margin-top: 5px; font-size: 11px; line-height: 1.3; opacity: 0.8;">
                                    Foundation: ${weights.foundationValue.toFixed(1)} | Sequence: ${weights.sequenceValue.toFixed(1)} | 
                                    Reveal: ${weights.revealValue.toFixed(1)} | Space: ${weights.emptySpaceValue.toFixed(1)} | 
                                    King: ${weights.kingPlacementValue.toFixed(1)} | Stock: ${weights.stockEfficiency.toFixed(1)}
                                </div>
                            </div>
                        `;
                    }
                    
                    // Determine AI mode display
                    const aiMode = mlAvailable ? 'Advanced Neural Networks + Complete Board Vision + Learning' : 'Enhanced Heuristics';
                    const aiIcon = mlAvailable ? '🧠' : '🎯';
                    const aiStatus = mlAvailable ? 
                        'Full AI system with neural networks, complete board analysis, learning algorithms, and strategic planning' :
                        'Using mathematical analysis and pattern recognition';
                    
                    // Game metrics
                    const foundationCards = Object.values(this.game.state.foundations).reduce((sum, pile) => sum + pile.length, 0);
                    const blockedCards = this.game.state.tableau.reduce((sum, pile) => 
                        sum + pile.filter(card => !card.faceUp).length, 0);
                    const emptySpaces = this.game.state.tableau.filter(pile => pile.length === 0).length;
                    const moveEfficiency = this.game.state.gameStats.moves > 0 ? 
                        Math.round((foundationCards / this.game.state.gameStats.moves) * 100) : 0;
                    
                    const message = `
                        <div style="text-align: left; line-height: 1.5; font-size: 13px; max-width: 700px; display: grid; grid-template-columns: 1fr 1fr; gap: 12px;">
                            <div style="grid-column: 1 / -1; font-size: 18px; font-weight: bold; margin-bottom: 15px; text-align: center;">
                                ${aiIcon} AI Complete Analysis
                            </div>
                            
                            <!-- Left Column -->
                            <div>
                                <div style="background: rgba(255,255,255,0.1); padding: 12px; border-radius: 6px; margin-bottom: 12px;">
                                    <strong>🎯 Win Probability: ${Math.round(analysis.winProbability * 100)}%</strong><br>
                                    <div style="background: #374151; border-radius: 8px; height: 16px; margin-top: 6px; position: relative;">
                                        <div style="background: linear-gradient(90deg, #ef4444, #f59e0b, #4ade80); width: ${Math.round(analysis.winProbability * 100)}%; height: 100%; border-radius: 8px;"></div>
                                    </div>
                                </div>
                                
                                <div style="background: rgba(255,255,255,0.1); padding: 12px; border-radius: 6px; margin-bottom: 12px;">
                                    <strong>📊 Game Metrics</strong><br>
                                    <div style="font-size: 12px; margin-top: 6px;">
                                        Progress: ${foundationCards}/52 (${Math.round((foundationCards/52)*100)}%) | Hidden: ${blockedCards}<br>
                                        Empty spaces: ${emptySpaces} | Efficiency: ${moveEfficiency}%<br>
                                        Difficulty: <span class="difficulty-indicator diff-${analysis.difficulty}">${analysis.difficulty.toUpperCase()}</span>
                                    </div>
                                </div>
                                
                                <div style="background: rgba(255,255,255,0.1); padding: 12px; border-radius: 6px; margin-bottom: 12px;">
                                    <strong>🎯 Top Moves</strong><br>
                                    <div style="font-size: 12px; margin-top: 6px; line-height: 1.3;">
                                        ${moves && moves.length > 0 ? moves.slice(0, 3).map((move, i) => {
                                            const score = move.aiScore !== undefined ? Math.round(move.aiScore) : Math.round((move.priority / 20) * 100);
                                            return `${i + 1}. ${move.description} (${score}${move.aiScore !== undefined ? 'pts' : '%'})`;
                                        }).join('<br>') : 'No immediate moves - check stock'}
                                    </div>
                                </div>
                                
                                ${analysis.stockRecommendation ? `
                                <div style="background: rgba(255,255,255,0.1); padding: 12px; border-radius: 6px;">
                                    <strong>📚 Stock Strategy</strong><br>
                                    <div style="font-size: 12px; margin-top: 6px;">
                                        <span style="color: ${analysis.stockRecommendation.shouldDraw ? '#4ade80' : '#f59e0b'};">
                                            ${analysis.stockRecommendation.shouldDraw ? '✅ Draw' : '⏸️ Wait'}
                                        </span> - ${analysis.stockRecommendation.reason}<br>
                                        ${analysis.stockRecommendation.upcomingCards ? `Next: ${analysis.stockRecommendation.upcomingCards.slice(0,3).join(', ')}` : ''}
                                    </div>
                                </div>
                                ` : ''}
                            </div>
                            
                            <!-- Right Column -->
                            <div>
                                ${analysis.hiddenCardInsights && analysis.hiddenCardInsights.insights.length > 0 ? `
                                <div style="background: rgba(255,255,255,0.1); padding: 12px; border-radius: 6px; margin-bottom: 12px;">
                                    <strong>🔍 Hidden Cards (${analysis.hiddenCardInsights.count})</strong><br>
                                    <div style="font-size: 12px; margin-top: 6px; line-height: 1.3;">
                                        Value: ${analysis.hiddenCardInsights.totalValue}<br>
                                        ${analysis.hiddenCardInsights.insights.slice(0, 3).map(insight => `• ${insight}`).join('<br>')}
                                    </div>
                                </div>
                                ` : ''}
                                
                                ${analysis.learningInsights ? `
                                <div style="background: rgba(255,255,255,0.1); padding: 12px; border-radius: 6px; margin-bottom: 12px;">
                                    <strong>🧠 AI Learning</strong><br>
                                    <div style="font-size: 12px; margin-top: 6px;">
                                        Database: ${analysis.learningInsights.totalLearningData} wins<br>
                                        Similar positions: ${analysis.learningInsights.similarWinningGames}<br>
                                        Confidence boost: +${Math.round(analysis.learningInsights.confidenceBoost * 100)}%
                                    </div>
                                </div>
                                ` : ''}
                                
                                ${analysis.strategicInsights && analysis.strategicInsights.length > 0 ? `
                                <div style="background: rgba(255,255,255,0.1); padding: 12px; border-radius: 6px; margin-bottom: 12px;">
                                    <strong>🎯 Strategic Insights</strong><br>
                                    <div style="font-size: 12px; margin-top: 6px; line-height: 1.3;">
                                        ${analysis.strategicInsights.slice(0, 3).map(insight => `• ${insight}`).join('<br>')}
                                    </div>
                                </div>
                                ` : ''}
                                
                                ${analysis.webAIInsights ? `
                                <div style="background: rgba(255,255,255,0.1); padding: 12px; border-radius: 6px; margin-bottom: 12px;">
                                    <strong>🌐 External AI</strong><br>
                                    <div style="font-size: 12px; margin-top: 6px;">
                                        Confidence: ${Math.round(analysis.webAIInsights.confidence * 100)}%<br>
                                        Risk: ${analysis.webAIInsights.riskAssessment}
                                    </div>
                                </div>
                                ` : ''}
                                
                                ${analysis.neuralWeights && mlAvailable ? `
                                <div style="background: rgba(255,255,255,0.05); padding: 10px; border-radius: 6px;">
                                    <strong>🧮 Neural Weights</strong><br>
                                    <div style="font-size: 11px; margin-top: 4px; opacity: 0.8;">
                                        F:${analysis.neuralWeights.foundationValue.toFixed(1)} S:${analysis.neuralWeights.sequenceValue.toFixed(1)} 
                                        R:${analysis.neuralWeights.revealValue.toFixed(1)} E:${analysis.neuralWeights.emptySpaceValue.toFixed(1)}
                                    </div>
                                </div>
                                ` : ''}
                            </div>
                            
                            <div style="grid-column: 1 / -1; background: rgba(255,255,255,0.1); padding: 12px; border-radius: 6px; margin-top: 8px;">
                                <strong>💭 AI Recommendation:</strong><br>
                                <span style="color: #a78bfa; font-style: italic;">${analysis.recommendation}</span>
                            </div>
                            
                            <div style="grid-column: 1 / -1; text-align: center; font-size: 11px; opacity: 0.7; margin-top: 8px;">
                                <strong>Powered by:</strong> ${aiMode}
                            </div>
                        </div>
                    `;
                    
                    this.showNotification(message, 'hint', 25000);
                    
                } catch (error) {
                    console.error('Enhanced analysis error:', error);
                    
                    const moves = this.game.ai.findAllPossibleMoves();
                    const moveCount = moves.length;
                    const foundationCards = Object.values(this.game.state.foundations).reduce((sum, pile) => sum + pile.length, 0);
                    const progress = Math.round((foundationCards / 52) * 100);
                    
                    this.showNotification(`
                        <div style="text-align: center;">
                            <h3>🎯 Quick Analysis</h3>
                            <p><strong>Game Progress:</strong> ${progress}%</p>
                            <p><strong>Available Moves:</strong> ${moveCount}</p>
                            <p><strong>Status:</strong> ${moveCount > 0 ? 'Keep playing! 🎮' : 'Try drawing from stock 📚'}</p>
                            <p><small>Advanced AI analysis temporarily unavailable</small></p>
                        </div>
                    `, 'hint', 5000);
                }
            }
        }

        // Card manager
        class CardManager {
            constructor(gameInstance) {
                this.game = gameInstance;
            }
            
            createDeck() {
                return this.game.constants.SUITS.flatMap(suit =>
                    this.game.constants.RANKS.map((rank, index) => ({
                        id: `${rank}${suit}`,
                        suit,
                        rank,
                        value: index + 1,
                        faceUp: false
                    }))
                );
            }
            
            shuffle(deck) {
                const shuffled = [...deck];
                for (let i = shuffled.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
                }
                return shuffled;
            }
            
            findCardLocation(card) {
                // Check waste pile
                for (let i = 0; i < this.game.state.waste.length; i++) {
                    if (this.game.state.waste[i].id === card.id) {
                        return { type: 'waste', index: i };
                    }
                }
                
                // Check foundation piles
                for (const [suit, pile] of Object.entries(this.game.state.foundations)) {
                    for (let i = 0; i < pile.length; i++) {
                        if (pile[i].id === card.id) {
                            return { type: 'foundation', suit: suit, index: i };
                        }
                    }
                }
                
                // Check tableau piles
                for (let pileIndex = 0; pileIndex < this.game.state.tableau.length; pileIndex++) {
                    const pile = this.game.state.tableau[pileIndex];
                    for (let cardIndex = 0; cardIndex < pile.length; cardIndex++) {
                        if (pile[cardIndex].id === card.id) {
                            return { type: 'tableau', pileIndex: pileIndex, cardIndex: cardIndex };
                        }
                    }
                }
                
                return null;
            }
        }

        // Game state
        class GameState {
            constructor(gameInstance) {
                this.game = gameInstance;
                this.drawMode = null;
                this.stock = [];
                this.waste = [];
                this.tableau = Array.from({ length: 7 }, () => []);
                this.foundations = { '♠': [], '♥': [], '♦': [], '♣': [] };
                this.gameStats = { moves: 0, time: 0, score: 0 };
                this.hintCardId = null;
                this.hoveredCard = null;
            }
            
            saveGameState() {
                if (!this.game.gameHistory) {
                    this.game.gameHistory = [];
                }
                
                // Create a deep copy of the current state
                const currentState = {
                    stock: this.stock.map(card => ({ ...card })),
                    waste: this.waste.map(card => ({ ...card })),
                    tableau: this.tableau.map(pile => pile.map(card => ({ ...card }))),
                    foundations: Object.fromEntries(
                        Object.entries(this.foundations).map(([suit, pile]) => 
                            [suit, pile.map(card => ({ ...card }))]
                        )
                    ),
                    gameStats: { ...this.gameStats }
                };
                
                // Add to history
                this.game.gameHistory.push(currentState);
                
                // Limit history size
                if (this.game.gameHistory.length > this.game.constants.MAX_HISTORY_SIZE) {
                    this.game.gameHistory.shift();
                }
            }
            
            initializeGame() {
                try {
                    this.gameStats = { moves: 0, time: 0, score: 0 };
                    this.hintCardId = null;
                    this.game.gameWon = false;
                    this.hoveredCard = null;
                    this.game.input.resetDragState();
                    
                    if (this.game.timer) clearInterval(this.game.timer);
                    
                    const deck = this.game.cards.shuffle(this.game.cards.createDeck());
                    
                    this.tableau = Array.from({ length: 7 }, () => []);
                    for (let col = 0; col < 7; col++) {
                        for (let row = 0; row <= col; row++) {
                            const card = deck.pop();
                            card.faceUp = row === col;
                            this.tableau[col].push(card);
                        }
                    }
                    
                    this.stock = deck;
                    this.waste = [];
                    this.foundations = { '♠': [], '♥': [], '♦': [], '♣': [] };
                    
                    // Clear game history when starting a new game
                    this.game.gameHistory = [];
                    this.game.redoHistory = [];
                    
                    if (this.game.settings.data.scoringMode === 'vegas') {
                        this.gameStats.score = -52;
                    }
                    
                    this.saveGameState(); // Save initial state
                } catch (error) {
                    console.error('Error initializing game:', error);
                }
            }
            
            startTimer() {
                this.game.timer = setInterval(() => {
                    this.gameStats.time++;
                    
                    if (this.game.settings.data.scoringMode === 'vegas' && this.gameStats.time % 10 === 0) {
                        this.gameStats.score = Math.max(-999, this.gameStats.score - 2);
                    }
                    
                    this.game.ui.updateUI();
                }, 1000);
            }
            
            updateScore(action) {
                const isVegas = this.game.settings.data.scoringMode === 'vegas';
                
                switch(action) {
                    case 'foundation':
                        this.gameStats.score += isVegas ? 5 : 10;
                        break;
                    case 'reveal':
                        this.gameStats.score += 5;
                        break;
                    case 'waste_to_tableau':
                        this.gameStats.score += isVegas ? 0 : 5;
                        break;
                    case 'tableau_to_tableau':
                        this.gameStats.score += isVegas ? 0 : 3;
                        break;
                    case 'foundation_to_tableau':
                        this.gameStats.score -= isVegas ? 5 : 15;
                        break;
                    case 'win_bonus':
                        if (isVegas) {
                            this.gameStats.score += 500;
                        } else {
                            const timeBonus = Math.max(0, 1000 - this.gameStats.time);
                            const moveBonus = Math.max(0, 500 - this.gameStats.moves);
                            this.gameStats.score += timeBonus + moveBonus;
                        }
                        break;
                }
                
                if (isVegas) {
                    this.gameStats.score = Math.max(-999, Math.min(9999, this.gameStats.score));
                } else {
                    this.gameStats.score = Math.max(0, this.gameStats.score);
                }
            }
            
            checkWinCondition() {
                const totalFoundationCards = Object.values(this.foundations)
                    .reduce((sum, pile) => sum + pile.length, 0);
                
                if (totalFoundationCards === 52 && !this.game.gameWon) {
                    this.game.gameWon = true;
                    if (this.game.timer) clearInterval(this.game.timer);
                    
                    // Victory effects
                    this.game.haptics.victory();
                    if (this.game.particles) {
                        // Create victory particles across the screen
                        for (let i = 0; i < 5; i++) {
                            setTimeout(() => {
                                const x = Math.random() * 1000;
                                const y = Math.random() * 600;
                                this.game.particles.createVictoryEffect(x, y);
                            }, i * 200);
                        }
                    }
                    
                    this.updateScore('win_bonus');
                    
                    // Record game completion for advanced ML learning
                    if (this.game.ml && !this.game.ml.isDisposed) {
                        try {
                            const allMoves = this.game.gameHistory.map(state => ({
                                type: 'game_state',
                                gameStats: state.gameStats,
                                timestamp: Date.now()
                            }));
                            
                            // Record the winning game for learning
                            this.game.ml.recordGameOutcome(this, allMoves, true);
                            
                            console.log('🧠 Recorded winning game for AI learning');
                        } catch (mlError) {
                            console.warn('Error recording game completion for ML:', mlError);
                        }
                    }
                    
                    this.game.stats.updateGameStatistics(true);
                    
                    setTimeout(() => {
                        this.game.ui.showWinModal();
                    }, 500);
                    
                    this.game.ui.updateUI();
                } else {
                    // Check for deadlock condition
                    this.checkDeadlockCondition();
                }
            }
            
            checkDeadlockCondition() {
                if (this.game.gameWon) return; // Already won, no need to check
                
                // Get all possible moves
                const possibleMoves = this.game.ai.findAllPossibleMoves();
                
                // Check if we can draw more cards from stock
                const canDrawFromStock = this.stock.length > 0 || 
                    (this.stock.length === 0 && this.waste.length > 0);
                
                // If no moves available and can't draw from stock, it's a deadlock
                if (possibleMoves.length === 0 && !canDrawFromStock) {
                    this.handleDeadlock();
                }
            }
            
            handleDeadlock() {
                console.log('🚫 Deadlock detected!');
                
                if (this.game.timer) clearInterval(this.game.timer);
                
                // Record deadlock for ML learning
                if (this.game.ml && !this.game.ml.isDisposed) {
                    try {
                        const gameHistory = this.game.gameHistory.map(state => ({
                            type: 'game_state',
                            gameStats: state.gameStats,
                            timestamp: Date.now()
                        }));
                        
                        // Analyze where the user went wrong
                        const analysis = this.analyzeDeadlockCause(gameHistory);
                        
                        // Record the deadlock as a loss for learning
                        this.game.ml.recordGameOutcome(this, gameHistory, false, {
                            reason: 'deadlock',
                            analysis: analysis,
                            finalState: {
                                foundationCards: Object.values(this.foundations).reduce((sum, pile) => sum + pile.length, 0),
                                hiddenCards: this.tableau.reduce((sum, pile) => sum + pile.filter(c => !c.faceUp).length, 0),
                                stockRemaining: this.stock.length,
                                wasteCards: this.waste.length
                            }
                        });
                        
                        console.log('🧠 Recorded deadlock for AI learning with analysis:', analysis);
                    } catch (mlError) {
                        console.warn('Error recording deadlock for ML:', mlError);
                    }
                }
                
                // Update statistics
                this.game.stats.updateGameStatistics(false);
                
                // Show deadlock notification
                setTimeout(() => {
                    this.game.ui.showDeadlockModal();
                }, 500);
            }
            
            analyzeDeadlockCause(gameHistory) {
                try {
                    const analysis = {
                        criticalMovePoint: null,
                        missedOpportunities: [],
                        suboptimalMoves: [],
                        stockCycles: 0,
                        foundationMissedMoves: 0
                    };
                    
                    // Analyze game history to find critical decisions
                    for (let i = 0; i < gameHistory.length; i++) {
                        const state = gameHistory[i];
                        
                        // Count stock cycles (going through waste pile)
                        if (i > 0 && state.gameStats.moves > gameHistory[i-1].gameStats.moves) {
                            // This was a move, check if it was drawing from empty stock
                            if (gameHistory[i-1].stock && gameHistory[i-1].stock.length === 0 && 
                                state.stock && state.stock.length > 0) {
                                analysis.stockCycles++;
                            }
                        }
                        
                        // Look for missed foundation opportunities
                        // (This would require more complex analysis of what cards were available)
                        
                        // Identify potential critical decision points
                        // Points where multiple high-value moves were available
                        if (i > 2 && i < gameHistory.length - 5) {
                            // This is a potential critical decision point
                            const progressBefore = this.calculateGameProgress(gameHistory[i-1]);
                            const progressAfter = this.calculateGameProgress(gameHistory[i+3]);
                            
                            if (progressAfter - progressBefore < 0.1) { // Low progress made
                                analysis.criticalMovePoint = i;
                            }
                        }
                    }
                    
                    // Determine primary cause
                    if (analysis.stockCycles > 3) {
                        analysis.primaryCause = 'excessive_stock_cycling';
                        analysis.suggestion = 'Try to focus on tableau moves and foundation building before cycling through the stock multiple times.';
                    } else if (analysis.criticalMovePoint) {
                        analysis.primaryCause = 'suboptimal_mid_game_decisions';
                        analysis.suggestion = `Critical decisions around move ${gameHistory[analysis.criticalMovePoint].gameStats.moves} may have limited future options.`;
                    } else {
                        analysis.primaryCause = 'unfavorable_initial_deal';
                        analysis.suggestion = 'This deal may have been particularly challenging. Focus on uncovering hidden cards early.';
                    }
                    
                    return analysis;
                } catch (error) {
                    console.warn('Error analyzing deadlock cause:', error);
                    return { primaryCause: 'analysis_error', suggestion: 'Unable to analyze the cause of deadlock.' };
                }
            }
            
            calculateGameProgress(state) {
                if (!state || !state.gameStats) return 0;
                
                // Simple progress metric based on foundations and exposed cards
                const foundationProgress = Object.values(state.foundations || {})
                    .reduce((sum, pile) => sum + pile.length, 0) / 52;
                const moveEfficiency = Math.min(state.gameStats.score / (state.gameStats.moves || 1), 1);
                
                return foundationProgress * 0.7 + moveEfficiency * 0.3;
            }
            
            saveToLocalStorage() {
                try {
                    const gameState = {
                        drawMode: this.drawMode,
                        currentGameMode: this.game.currentGameMode,
                        currentDifficulty: this.game.currentDifficulty,
                        stock: this.stock.map(card => ({ ...card })),
                        waste: this.waste.map(card => ({ ...card })),
                        tableau: this.tableau.map(pile => pile.map(card => ({ ...card }))),
                        foundations: Object.fromEntries(
                            Object.entries(this.foundations).map(([suit, pile]) => 
                                [suit, pile.map(card => ({ ...card }))]
                            )
                        ),
                        gameStats: { ...this.gameStats },
                        timestamp: Date.now()
                    };
                    
                    this.game.storage.set('klondike_save', gameState);
                } catch (error) {
                    console.error('Error saving game:', error);
                }
            }
            
            resetAllGameState() {
                if (this.game.timer) {
                    clearInterval(this.game.timer);
                    this.game.timer = null;
                }
                
                this.stock = [];
                this.waste = [];
                this.tableau = Array.from({ length: 7 }, () => []);
                this.foundations = { '♠': [], '♥': [], '♦': [], '♣': [] };
                this.gameStats = { moves: 0, time: 0, score: 0 };
                this.gameHistory = [];
                this.hintCardId = null;
                this.game.gameWon = false;
                this.hoveredCard = null;
                
                this.game.input.resetDragState();
                
                if (this.game.renderer.cardPositions) {
                    this.game.renderer.cardPositions.clear();
                }
            }
        }

        // Game rules
        class GameRules {
            constructor(gameInstance) {
                this.game = gameInstance;
            }
            
            canPlaceOnFoundation(card) {
                const pile = this.game.state.foundations[card.suit];
                const topCard = pile[pile.length - 1];
                return (card.value === 1 && pile.length === 0) || 
                       (topCard && card.value === topCard.value + 1);
            }
            
            canPlaceOnTableau(card, targetPile) {
                if (targetPile.length === 0) {
                    return card.value === 13;
                }
                const topCard = targetPile[targetPile.length - 1];
                return topCard.faceUp && 
                       topCard.value === card.value + 1 && 
                       this.game.constants.RED_SUITS.has(topCard.suit) !== this.game.constants.RED_SUITS.has(card.suit);
            }
            
            isValidSequence(cards) {
                if (cards.length <= 1) return true;
                
                for (let i = 1; i < cards.length; i++) {
                    const prevCard = cards[i - 1];
                    const currCard = cards[i];
                    
                    if (prevCard.value !== currCard.value + 1 ||
                        this.game.constants.RED_SUITS.has(prevCard.suit) === this.game.constants.RED_SUITS.has(currCard.suit)) {
                        return false;
                    }
                }
                return true;
            }
            
            isSafeToAutoMove(card) {
                if (card.value <= 2) return true;
                
                const oppositeColors = this.game.constants.RED_SUITS.has(card.suit) ? ['♠', '♣'] : ['♥', '♦'];
                const requiredValue = card.value - 1;
                
                return oppositeColors.every(suit => {
                    const pile = this.game.state.foundations[suit];
                    return pile.length >= requiredValue;
                });
            }
            
            checkAutoMoveToFoundation() {
                if (!this.game.settings.data.autoMoveToFoundation) return false;
                
                let moved = false;
                
                if (this.game.state.waste.length > 0) {
                    const topCard = this.game.state.waste[this.game.state.waste.length - 1];
                    if (this.canPlaceOnFoundation(topCard) && this.isSafeToAutoMove(topCard)) {
                        this.game.ai.moveCardToFoundation(topCard);
                        moved = true;
                    }
                }
                
                for (let i = 0; i < this.game.state.tableau.length; i++) {
                    const pile = this.game.state.tableau[i];
                    if (pile.length > 0) {
                        const topCard = pile[pile.length - 1];
                        if (topCard.faceUp && this.canPlaceOnFoundation(topCard) && this.isSafeToAutoMove(topCard)) {
                            this.game.ai.moveCardToFoundation(topCard);
                            moved = true;
                            break;
                        }
                    }
                }
                
                return moved;
            }
        }

        // AI hint system
        class AIHintSystem {
            constructor(gameInstance) {
                this.game = gameInstance;
            }
            
            async showHint() {
                try {
                    this.game.sound.play('cardFlip');
                    
                    const moves = this.findAllPossibleMoves();
                    this.game.state.hintCardId = null;
                    
                    if (moves.length > 0) {
                        let bestMove, analysis, smartMoves;
                        
                        // Use advanced ML evaluation for each move
                        try {
                            if (this.game.ml && this.game.ml.isInitialized && this.game.settings.data.enableMLAnalysis) {
                                console.log('🧠 Using advanced AI analysis...');
                                
                                // Evaluate all moves with advanced AI
                                const evaluatedMoves = [];
                                for (const move of moves) {
                                    const evaluation = await this.game.ml.evaluateMove(move, this.game.state);
                                    evaluatedMoves.push(evaluation);
                                }
                                
                                // Sort by AI score
                                smartMoves = evaluatedMoves.sort((a, b) => b.aiScore - a.aiScore);
                                bestMove = smartMoves[0];
                                
                                // Get comprehensive game analysis
                                analysis = await this.game.ml.getGameAnalysis(this.game.state);
                            }
                        } catch (mlError) {
                            console.warn('Advanced AI analysis failed, using fallback:', mlError);
                        }
                        
                        // Fallback to basic prioritization if ML failed
                        if (!bestMove) {
                            smartMoves = this.prioritizeMoves(moves);
                            bestMove = smartMoves[0];
                            analysis = {
                                winProbability: 0.5,
                                difficulty: 'unknown',
                                recommendation: 'Keep playing strategically!',
                                stockRecommendation: { shouldDraw: true, reason: 'Standard progression' }
                            };
                        }
                        
                        this.game.state.hintCardId = bestMove.cardId;
                        this.game.renderer.render();
                        
                        // Create enhanced hint message with full AI capabilities
                        const mlMode = this.game.ml && this.game.ml.isInitialized && !this.game.ml.fallbackMode;
                        const aiIcon = mlMode ? '🧠' : '🎯';
                        const aiType = mlMode ? 'Advanced AI with Complete Board Vision' : 'Smart Analysis';
                        
                        // Prepare move reasoning
                        let moveReasoning = '';
                        if (bestMove.strategicReasoning && bestMove.strategicReasoning.length > 0) {
                            moveReasoning = `
                                <div style="margin-top: 10px; padding: 8px; background: rgba(255,255,255,0.1); border-radius: 6px;">
                                    <strong>🎯 Strategic Reasoning:</strong><br>
                                    <ul style="margin: 5px 0; padding-left: 20px; font-size: 12px;">
                                        ${bestMove.strategicReasoning.map(reason => `<li>${reason}</li>`).join('')}
                                    </ul>
                                </div>
                            `;
                        }
                        
                        // Stock drawing recommendation
                        let stockAdvice = '';
                        if (analysis.stockRecommendation) {
                            const stockRec = analysis.stockRecommendation;
                            stockAdvice = `
                                <div style="margin-top: 10px; padding: 8px; background: rgba(255,255,255,0.1); border-radius: 6px;">
                                    <strong>📚 Stock Strategy:</strong><br>
                                    <span style="color: ${stockRec.shouldDraw ? '#4ade80' : '#f59e0b'};">
                                        ${stockRec.shouldDraw ? '✅ Draw from stock' : '⏸️ Focus on tableau first'}
                                    </span><br>
                                    <small>${stockRec.reason}</small>
                                    ${stockRec.upcomingCards ? `<br><small>Next cards: ${stockRec.upcomingCards.join(', ')}</small>` : ''}
                                </div>
                            `;
                        }
                        
                        // Hidden cards insights
                        let hiddenInsights = '';
                        if (analysis.hiddenCardInsights && analysis.hiddenCardInsights.insights.length > 0) {
                            const insights = analysis.hiddenCardInsights.insights.slice(0, 3); // Show top 3
                            hiddenInsights = `
                                <div style="margin-top: 10px; padding: 8px; background: rgba(255,255,255,0.1); border-radius: 6px;">
                                    <strong>🔍 Hidden Card Intel:</strong><br>
                                    ${insights.map(insight => `<small>• ${insight}</small>`).join('<br>')}
                                </div>
                            `;
                        }
                        
                        // Learning insights
                        let learningInfo = '';
                        if (analysis.learningInsights && analysis.learningInsights.totalLearningData > 0) {
                            learningInfo = `
                                <div style="margin-top: 10px; padding: 8px; background: rgba(255,255,255,0.1); border-radius: 6px;">
                                    <strong>📖 AI Learning:</strong><br>
                                    <small>Learned from ${analysis.learningInsights.totalLearningData} winning games</small>
                                    ${analysis.learningInsights.insights.length > 0 ? '<br>' + analysis.learningInsights.insights.map(insight => `<small>• ${insight}</small>`).join('<br>') : ''}
                                </div>
                            `;
                        }
                        
                        // Alternative moves
                        let alternativeMoves = '';
                        if (smartMoves && smartMoves.length > 1) {
                            const alternatives = smartMoves.slice(1, 3);
                            alternativeMoves = `
                                <div style="margin-top: 10px; padding: 8px; background: rgba(255,255,255,0.05); border-radius: 6px;">
                                    <strong>🔄 Alternative Moves:</strong><br>
                                    ${alternatives.map((move, i) => {
                                        const score = move.aiScore ? Math.round(move.aiScore) : Math.round((move.priority / 20) * 100);
                                        return `<small>${i + 2}. ${move.description} (${score}%)</small>`;
                                    }).join('<br>')}
                                </div>
                            `;
                        }
                        
                        const message = `
                            <div style="text-align: left; line-height: 1.6; font-size: 14px; max-width: 500px;">
                                <div style="font-size: 18px; font-weight: bold; margin-bottom: 15px; text-align: center;">
                                    ${aiIcon} ${aiType}
                                </div>
                                
                                <div style="margin-bottom: 10px;">
                                    <strong>💡 Best Move:</strong><br>
                                    <span style="color: #4ade80; font-weight: bold;">${bestMove.description}</span>
                                    ${bestMove.aiScore ? `<span style="color: #a78bfa; font-size: 12px;"> (AI Score: ${Math.round(bestMove.aiScore)})</span>` : ''}
                                    ${bestMove.confidence ? `<span style="color: #fbbf24; font-size: 12px;"> (${Math.round(bestMove.confidence * 100)}% confidence)</span>` : ''}
                                </div>
                                
                                <div style="margin-bottom: 10px;">
                                    <strong>🎯 Win Probability:</strong> 
                                    <span style="color: ${analysis.winProbability > 0.6 ? '#4ade80' : analysis.winProbability > 0.3 ? '#f59e0b' : '#ef4444'};">
                                        ${Math.round(analysis.winProbability * 100)}%
                                    </span>
                                </div>
                                
                                <div style="margin-bottom: 10px;">
                                    <strong>📊 Difficulty:</strong> 
                                    <span class="difficulty-indicator diff-${analysis.difficulty}">${analysis.difficulty.toUpperCase()}</span>
                                </div>
                                
                                ${moveReasoning}
                                ${stockAdvice}
                                ${hiddenInsights}
                                ${learningInfo}
                                ${alternativeMoves}
                                
                                <div style="margin-top: 15px; padding-top: 10px; border-top: 1px solid rgba(255,255,255,0.3);">
                                    <strong>🤖 AI Recommendation:</strong><br>
                                    <span style="color: #a78bfa; font-style: italic;">${analysis.recommendation}</span>
                                </div>
                                
                                <div style="text-align: center; margin-top: 15px; font-size: 11px; opacity: 0.7;">
                                    <strong>Powered by:</strong> ${aiType}<br>
                                    ${mlMode ? 'Complete board vision • Learning algorithms • Strategic planning' : 'Mathematical analysis • Pattern recognition'}
                                </div>
                            </div>
                        `;
                        
                        this.game.ui.showNotification(message, 'hint', 20000);
                        
                    } else if (this.game.state.stock.length > 0 || this.game.state.waste.length > 0) {
                        // No moves available - provide stock drawing guidance
                        let stockGuidance = '';
                        try {
                            if (this.game.ml && this.game.ml.isInitialized) {
                                const stockAnalysis = await this.game.ml.recommendStockDrawing(this.game.state);
                                stockGuidance = `
                                    <br><strong>📚 Stock Analysis:</strong><br>
                                    <small>${stockAnalysis.reason}</small>
                                    ${stockAnalysis.upcomingCards ? `<br><small>Next: ${stockAnalysis.upcomingCards.join(', ')}</small>` : ''}
                                `;
                            }
                        } catch (error) {
                            console.warn('Stock analysis failed:', error);
                        }
                        
                        this.game.ui.showNotification(`📚 Draw from stock to reveal new options${stockGuidance}`, 'hint', 5000);
                    } else {
                        // No moves and no stock - advanced analysis for stuck situations
                        let stuckAnalysis = '';
                        try {
                            if (this.game.ml && this.game.ml.isInitialized) {
                                const analysis = await this.game.ml.getGameAnalysis(this.game.state);
                                stuckAnalysis = `<br><small>${analysis.recommendation}</small>`;
                            }
                        } catch (error) {
                            console.warn('Stuck analysis failed:', error);
                        }
                        
                        this.game.ui.showNotification(`❌ No moves available${stuckAnalysis}<br><small>Consider undoing recent moves or starting fresh.</small>`, 'hint', 4000);
                    }
                } catch (error) {
                    console.error('Error showing enhanced hint:', error);
                    // Emergency fallback
                    this.game.ui.showNotification('💡 Try drawing from the stock pile or look for foundation moves', 'hint', 3000);
                }
            }
            
            findAllPossibleMoves() {
                const moves = [];
                
                moves.push(...this.findFoundationMoves());
                moves.push(...this.findTableauMoves());
                moves.push(...this.findWasteMoves());
                
                return moves;
            }
            
            findFoundationMoves() {
                const moves = [];
                
                // Check waste pile
                if (this.game.state.waste.length > 0) {
                    const topCard = this.game.state.waste[this.game.state.waste.length - 1];
                    if (this.game.rules.canPlaceOnFoundation(topCard)) {
                        let priority = 10 + topCard.value;
                        
                        // Extra priority for breaking deadlocks (6s that can move to foundation)
                        if (topCard.value === 6 && this.hasLateralMovesSixOrFive()) {
                            priority += 15;
                        }
                        
                        moves.push({
                            type: 'foundation',
                            cardId: topCard.id,
                            card: topCard,
                            priority: priority,
                            description: `Move ${topCard.rank}${topCard.suit} to foundation`
                        });
                    }
                }
                
                // Check tableau piles
                for (let i = 0; i < this.game.state.tableau.length; i++) {
                    const pile = this.game.state.tableau[i];
                    if (pile.length > 0) {
                        const topCard = pile[pile.length - 1];
                        if (topCard.faceUp && this.game.rules.canPlaceOnFoundation(topCard)) {
                            const willReveal = pile.length > 1 && pile[pile.length - 2] && !pile[pile.length - 2].faceUp;
                            let priority = 10 + topCard.value + (willReveal ? 5 : 0);
                            
                            // Extra priority for breaking deadlocks (6s that can move to foundation)
                            if (topCard.value === 6 && this.hasLateralMovesSixOrFive()) {
                                priority += 15;
                                console.log(`🎯 Found 6 that can break deadlock: ${topCard.rank}${topCard.suit}`);
                            }
                            
                            moves.push({
                                type: 'foundation',
                                cardId: topCard.id,
                                card: topCard,
                                priority: priority,
                                description: `Move ${topCard.rank}${topCard.suit} to foundation${willReveal ? ' (reveals card)' : ''}${topCard.value === 6 && this.hasLateralMovesSixOrFive() ? ' (breaks deadlock!)' : ''}`
                            });
                        }
                    }
                }
                
                return moves;
            }
            
            hasLateralMovesSixOrFive() {
                // Check if there are 5s or 6s that can move between multiple black 6s (deadlock pattern)
                let blackSixes = 0;
                let redFives = 0;
                
                // Count black 6s and red 5s that can move laterally
                for (let i = 0; i < this.game.state.tableau.length; i++) {
                    const pile = this.game.state.tableau[i];
                    if (pile.length > 0) {
                        const topCard = pile[pile.length - 1];
                        if (topCard.faceUp) {
                            // Count black 6s on tableau
                            if (topCard.value === 6 && (topCard.suit === '♠' || topCard.suit === '♣')) {
                                blackSixes++;
                            }
                            // Count red 5s that could move between them
                            if (topCard.value === 5 && (topCard.suit === '♥' || topCard.suit === '♦')) {
                                redFives++;
                            }
                        }
                    }
                }
                
                // Also check waste for red 5s
                if (this.game.state.waste.length > 0) {
                    const wasteCard = this.game.state.waste[this.game.state.waste.length - 1];
                    if (wasteCard.value === 5 && (wasteCard.suit === '♥' || wasteCard.suit === '♦')) {
                        redFives++;
                    }
                }
                
                // Deadlock pattern: multiple black 6s with red 5s that can bounce between them
                return blackSixes >= 2 && redFives >= 1;
            }
            
            findTableauMoves() {
                const moves = [];
                
                for (let i = 0; i < this.game.state.tableau.length; i++) {
                    const pile = this.game.state.tableau[i];
                    if (pile.length === 0) continue;
                    
                    const topCard = pile[pile.length - 1];
                    if (!topCard.faceUp) continue;
                    
                    for (let j = 0; j < this.game.state.tableau.length; j++) {
                        if (i !== j && this.game.rules.canPlaceOnTableau(topCard, this.game.state.tableau[j])) {
                            const targetEmpty = this.game.state.tableau[j].length === 0;
                            const priority = targetEmpty && topCard.value !== 13 ? 2 : 5;
                            
                            moves.push({
                                type: 'tableau',
                                cardId: topCard.id,
                                card: topCard,
                                priority: priority,
                                description: `Move ${topCard.rank}${topCard.suit} to ${targetEmpty ? 'empty space' : 'tableau pile'}`
                            });
                        }
                    }
                }
                
                return moves;
            }
            
            findWasteMoves() {
                const moves = [];
                
                if (this.game.state.waste.length === 0) return moves;
                
                const topCard = this.game.state.waste[this.game.state.waste.length - 1];
                
                for (let i = 0; i < this.game.state.tableau.length; i++) {
                    if (this.game.rules.canPlaceOnTableau(topCard, this.game.state.tableau[i])) {
                        const targetEmpty = this.game.state.tableau[i].length === 0;
                        const priority = targetEmpty && topCard.value !== 13 ? 3 : 6;
                        
                        moves.push({
                            type: 'waste-to-tableau',
                            cardId: topCard.id,
                            card: topCard,
                            priority: priority,
                            description: `Move ${topCard.rank}${topCard.suit} from waste to tableau`
                        });
                    }
                }
                
                return moves;
            }
            
            prioritizeMoves(moves) {
                // Check for deadlock patterns (lateral moves)
                const lateralMoves = this.detectLateralMoves(moves);
                
                // Enhanced prioritization
                const prioritizedMoves = moves.map(move => {
                    let enhancedPriority = move.priority;
                    
                    // Heavily prioritize foundation moves
                    if (move.type === 'foundation') {
                        enhancedPriority += 20;
                        
                        // Special priority for foundation moves that break deadlocks
                        if (this.isFoundationMoveBreaksDeadlock(move)) {
                            enhancedPriority += 10;
                        }
                    }
                    
                    // Penalize lateral moves (moves that don't advance game state)
                    if (lateralMoves.includes(move)) {
                        enhancedPriority -= 15;
                    }
                    
                    // Check if move creates meaningful progress
                    if (this.createsMeaningfulProgress(move)) {
                        enhancedPriority += 5;
                    }
                    
                    // Penalize repetitive patterns
                    if (this.isRepetitiveMove(move)) {
                        enhancedPriority -= 10;
                    }
                    
                    return { ...move, enhancedPriority };
                });
                
                return prioritizedMoves.sort((a, b) => {
                    if (a.enhancedPriority !== b.enhancedPriority) {
                        return b.enhancedPriority - a.enhancedPriority;
                    }
                    
                    // Secondary sort by type
                    const typeOrder = { foundation: 4, tableau: 2, 'waste-to-tableau': 1 };
                    return (typeOrder[b.type] || 0) - (typeOrder[a.type] || 0);
                });
            }
            
            detectLateralMoves(moves) {
                const lateralMoves = [];
                
                // Look for cards that can move between multiple tableau positions
                const cardTargets = new Map();
                
                moves.forEach(move => {
                    if (move.type === 'tableau' && move.card) {
                        const cardKey = `${move.card.value}-${move.card.suit}`;
                        if (!cardTargets.has(cardKey)) {
                            cardTargets.set(cardKey, []);
                        }
                        cardTargets.get(cardKey).push(move);
                    }
                });
                
                // Identify cards with multiple possible placements (potential lateral moves)
                cardTargets.forEach((movesForCard, cardKey) => {
                    if (movesForCard.length > 1) {
                        // These are potential lateral moves - add penalty
                        lateralMoves.push(...movesForCard);
                    }
                });
                
                return lateralMoves;
            }
            
            isFoundationMoveBreaksDeadlock(move) {
                if (move.type !== 'foundation' || !move.card) return false;
                
                // Check if this foundation move would free up cards for other foundation moves
                const cardValue = move.card.value;
                const cardSuit = move.card.suit;
                
                // Look for cards that could benefit from this foundation move
                for (let i = 0; i < this.game.state.tableau.length; i++) {
                    const pile = this.game.state.tableau[i];
                    for (let j = 0; j < pile.length; j++) {
                        const card = pile[j];
                        if (card.faceUp && card.suit === cardSuit && card.value === cardValue + 1) {
                            // This foundation move would enable the next card in sequence
                            return true;
                        }
                    }
                }
                
                return false;
            }
            
            createsMeaningfulProgress(move) {
                if (!move.card) return false;
                
                // Foundation moves always create meaningful progress
                if (move.type === 'foundation') return true;
                
                // Moving Kings to empty spaces is meaningful
                if (move.card.value === 13 && move.description && move.description.includes('empty space')) {
                    return true;
                }
                
                // Moves that reveal hidden cards are meaningful
                if (move.description && move.description.includes('reveals card')) {
                    return true;
                }
                
                return false;
            }
            
            isRepetitiveMove(move) {
                // Simple check for recently made similar moves
                // This could be enhanced with move history tracking
                if (!this.game.state.gameHistory || this.game.state.gameHistory.length === 0) {
                    return false;
                }
                
                const recentMoves = this.game.state.gameHistory.slice(-5); // Check last 5 moves
                const currentMoveSignature = `${move.card?.value}-${move.card?.suit}-${move.type}`;
                
                return recentMoves.some(historicalMove => {
                    if (!historicalMove.move) return false;
                    const histSignature = `${historicalMove.move.card?.value}-${historicalMove.move.card?.suit}-${historicalMove.move.type}`;
                    return histSignature === currentMoveSignature;
                });
            }
            
            moveCardToFoundation(card) {
                const cardLocation = this.game.cards.findCardLocation(card);
                if (!cardLocation) return;
                
                if (cardLocation.type === 'tableau') {
                    const pile = this.game.state.tableau[cardLocation.pileIndex];
                    const isTopCard = cardLocation.cardIndex === pile.length - 1;
                    if (!isTopCard) return;
                }
                
                this.game.state.saveGameState();
                this.game.state.gameStats.moves++;
                
                if (cardLocation.type === 'waste') {
                    const wasteIndex = this.game.state.waste.findIndex(c => c.id === card.id);
                    if (wasteIndex === this.game.state.waste.length - 1) {
                        this.game.state.waste.pop();
                    }
                } else if (cardLocation.type === 'foundation') {
                    const pile = this.game.state.foundations[cardLocation.suit];
                    if (pile.length > 0 && pile[pile.length - 1].id === card.id) {
                        pile.pop();
                    }
                } else if (cardLocation.type === 'tableau') {
                    const pile = this.game.state.tableau[cardLocation.pileIndex];
                    if (pile.length > 0 && pile[pile.length - 1].id === card.id) {
                        pile.pop();
                        if (pile.length > 0 && !pile[pile.length - 1].faceUp) {
                            pile[pile.length - 1].faceUp = true;
                            this.game.state.updateScore('reveal');
                        }
                    }
                }
                
                this.game.state.foundations[card.suit].push(card);
                this.game.state.updateScore('foundation');
                
                this.game.state.hintCardId = null;
                this.game.state.hoveredCard = null;
                this.game.ui.updateUI();
                this.game.renderer.render();
                
                setTimeout(() => {
                    if (this.game.rules.checkAutoMoveToFoundation()) {
                        this.game.renderer.render();
                    }
                }, 300);
            }
            
            attemptAutoMove(card) {
                try {
                    const cardLocation = this.game.cards.findCardLocation(card);
                    if (!cardLocation) return false;
                    
                    if (cardLocation.type === 'tableau') {
                        const pile = this.game.state.tableau[cardLocation.pileIndex];
                        const cardIndex = cardLocation.cardIndex;
                        const isTopCard = cardIndex === pile.length - 1;
                        
                        if (isTopCard && this.game.rules.canPlaceOnFoundation(card)) {
                            this.moveCardToFoundation(card);
                            return true;
                        }
                        
                        const cardsToMove = pile.slice(cardIndex);
                        if (this.game.rules.isValidSequence(cardsToMove)) {
                            for (let i = 0; i < this.game.state.tableau.length; i++) {
                                if (i !== cardLocation.pileIndex && this.game.rules.canPlaceOnTableau(card, this.game.state.tableau[i])) {
                                    this.moveCardSequenceToTableau(card, cardLocation, i);
                                    return true;
                                }
                            }
                        }
                    } else {
                        if (this.game.rules.canPlaceOnFoundation(card)) {
                            this.moveCardToFoundation(card);
                            return true;
                        }
                        
                        for (let i = 0; i < this.game.state.tableau.length; i++) {
                            if (this.game.rules.canPlaceOnTableau(card, this.game.state.tableau[i])) {
                                this.moveCardToTableau(card, i);
                                return true;
                            }
                        }
                    }
                    
                    return false;
                } catch (error) {
                    console.error('Error attempting auto-move:', error);
                    return false;
                }
            }
            
            moveCardSequenceToTableau(card, sourceLocation, targetPileIndex) {
                this.game.state.saveGameState();
                this.game.state.gameStats.moves++;
                
                const sourcePile = this.game.state.tableau[sourceLocation.pileIndex];
                const cardIndex = sourceLocation.cardIndex;
                const movingCards = sourcePile.splice(cardIndex);
                
                if (sourcePile.length > 0 && !sourcePile[sourcePile.length - 1].faceUp) {
                    sourcePile[sourcePile.length - 1].faceUp = true;
                    this.game.state.updateScore('reveal');
                }
                
                this.game.state.tableau[targetPileIndex].push(...movingCards);
                this.game.state.updateScore('tableau_to_tableau');
                
                this.game.state.hintCardId = null;
                this.game.state.hoveredCard = null;
                this.game.ui.updateUI();
                this.game.renderer.render();
                
                setTimeout(() => {
                    if (this.game.rules.checkAutoMoveToFoundation()) {
                        this.game.renderer.render();
                    }
                }, 100);
            }
            
            moveCardToTableau(card, targetPileIndex) {
                const cardLocation = this.game.cards.findCardLocation(card);
                if (!cardLocation) return;
                
                this.game.state.saveGameState();
                this.game.state.gameStats.moves++;
                
                let moveType = 'tableau_to_tableau';
                
                if (cardLocation.type === 'waste') {
                    if (this.game.state.waste.length > 0 && this.game.state.waste[this.game.state.waste.length - 1].id === card.id) {
                        this.game.state.waste.pop();
                        this.game.state.tableau[targetPileIndex].push(card);
                        moveType = 'waste_to_tableau';
                    }
                } else if (cardLocation.type === 'foundation') {
                    const pile = this.game.state.foundations[cardLocation.suit];
                    if (pile.length > 0 && pile[pile.length - 1].id === card.id) {
                        pile.pop();
                        this.game.state.tableau[targetPileIndex].push(card);
                        moveType = 'foundation_to_tableau';
                    }
                } else if (cardLocation.type === 'tableau') {
                    this.moveCardSequenceToTableau(card, cardLocation, targetPileIndex);
                    return;
                }
                
                this.game.state.updateScore(moveType);
                
                this.game.state.hintCardId = null;
                this.game.state.hoveredCard = null;
                this.game.ui.updateUI();
                this.game.renderer.render();
                
                setTimeout(() => {
                    if (this.game.rules.checkAutoMoveToFoundation()) {
                        this.game.renderer.render();
                    }
                }, 100);
            }
            
            flipStock() {
                this.game.state.saveGameState();
                this.game.state.gameStats.moves++;
                this.game.sound.play('cardFlip');
                
                if (this.game.state.stock.length === 0) {
                    this.game.state.stock = this.game.state.waste.map(card => ({ ...card, faceUp: false })).reverse();
                    this.game.state.waste = [];
                    
                    if (this.game.settings.data.scoringMode === 'vegas') {
                        this.game.state.gameStats.score = Math.max(-999, this.game.state.gameStats.score - 100);
                    }
                } else {
                    const cardsToDraw = Math.min(this.game.state.drawMode, this.game.state.stock.length);
                    const drawn = this.game.state.stock.splice(-cardsToDraw).map(card => ({ ...card, faceUp: true }));
                    this.game.state.waste.push(...drawn);
                }
                
                this.game.state.hintCardId = null;
                this.game.state.hoveredCard = null;
                this.game.ui.updateUI();
                this.game.renderer.render();
            }
        }

        // Enhanced haptic feedback for mobile
        class HapticManager {
            static vibrate(pattern = 50) {
                if ('vibrate' in navigator) {
                    navigator.vibrate(pattern);
                }
            }
            
            static cardFlip() {
                this.vibrate([10]);
            }
            
            static cardPlace() {
                this.vibrate([30]);
            }
            
            static victory() {
                this.vibrate([100, 50, 100, 50, 200]);
            }
            
            static error() {
                this.vibrate([200]);
            }
        }

        // Particle effects system
        class ParticleSystem {
            constructor(canvas) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.particles = [];
            }
            
            createVictoryEffect(x, y) {
                for (let i = 0; i < 50; i++) {
                    this.particles.push({
                        x: x,
                        y: y,
                        vx: (Math.random() - 0.5) * 10,
                        vy: (Math.random() - 0.5) * 10,
                        life: 1.0,
                        decay: 0.02,
                        color: `hsl(${Math.random() * 60 + 300}, 100%, 50%)`
                    });
                }
            }
            
            createCardPlaceEffect(x, y) {
                for (let i = 0; i < 10; i++) {
                    this.particles.push({
                        x: x,
                        y: y,
                        vx: (Math.random() - 0.5) * 4,
                        vy: (Math.random() - 0.5) * 4,
                        life: 0.5,
                        decay: 0.05,
                        color: '#4ade80'
                    });
                }
            }
            
            update() {
                this.particles = this.particles.filter(particle => {
                    particle.x += particle.vx;
                    particle.y += particle.vy;
                    particle.vy += 0.2; // gravity
                    particle.life -= particle.decay;
                    return particle.life > 0;
                });
            }
            
            render() {
                this.particles.forEach(particle => {
                    this.ctx.save();
                    this.ctx.globalAlpha = particle.life;
                    this.ctx.fillStyle = particle.color;
                    this.ctx.beginPath();
                    this.ctx.arc(particle.x, particle.y, 3, 0, Math.PI * 2);
                    this.ctx.fill();
                    this.ctx.restore();
                });
            }
        }

        // Input manager
        class InputManager {
            constructor(gameInstance) {
                this.game = gameInstance;
                this.canvas = null;
                this.isDragging = false;
                this.draggedCards = [];
                this.dragCurrentPos = { x: 0, y: 0 };
                this.dragSourceInfo = null;
                this.dragOffset = { x: 0, y: 0 };
                
                this.boundHandlers = {
                    mouseDown: this.handleMouseDown.bind(this),
                    mouseMove: this.handleMouseMove.bind(this),
                    mouseUp: this.handleMouseUp.bind(this),
                    click: this.handleCanvasClick.bind(this),
                    doubleClick: this.handleCanvasDoubleClick.bind(this),
                    mouseLeave: this.handleMouseLeave.bind(this),
                    touchStart: this.handleTouchStart.bind(this),
                    touchMove: this.handleTouchMove.bind(this),
                    touchEnd: this.handleTouchEnd.bind(this),
                    keyDown: this.handleKeyDown.bind(this),
                    contextMenu: this.handleContextMenu.bind(this)
                };
            }
            
            initCanvas() {
                this.canvas = document.getElementById('gameCanvas');
                if (!this.canvas) return;
                
                this.canvas.addEventListener('mousedown', this.boundHandlers.mouseDown, false);
                this.canvas.addEventListener('mousemove', this.boundHandlers.mouseMove, false);
                this.canvas.addEventListener('mouseup', this.boundHandlers.mouseUp, false);
                this.canvas.addEventListener('click', this.boundHandlers.click, false);
                this.canvas.addEventListener('dblclick', this.boundHandlers.doubleClick, false);
                this.canvas.addEventListener('mouseleave', this.boundHandlers.mouseLeave, false);
                
                this.canvas.addEventListener('touchstart', this.boundHandlers.touchStart, { passive: false });
                this.canvas.addEventListener('touchmove', this.boundHandlers.touchMove, { passive: false });
                this.canvas.addEventListener('touchend', this.boundHandlers.touchEnd, { passive: false });
                
                document.addEventListener('keydown', this.boundHandlers.keyDown, false);
                
                this.canvas.addEventListener('contextmenu', this.boundHandlers.contextMenu, false);
                
                this.canvas.style.userSelect = 'none';
                this.canvas.style.touchAction = 'none';
                this.canvas.tabIndex = 0;
            }
            
            cleanup() {
                if (!this.canvas) return;
                
                this.canvas.removeEventListener('mousedown', this.boundHandlers.mouseDown);
                this.canvas.removeEventListener('mousemove', this.boundHandlers.mouseMove);
                this.canvas.removeEventListener('mouseup', this.boundHandlers.mouseUp);
                this.canvas.removeEventListener('click', this.boundHandlers.click);
                this.canvas.removeEventListener('dblclick', this.boundHandlers.doubleClick);
                this.canvas.removeEventListener('mouseleave', this.boundHandlers.mouseLeave);
                this.canvas.removeEventListener('touchstart', this.boundHandlers.touchStart);
                this.canvas.removeEventListener('touchmove', this.boundHandlers.touchMove);
                this.canvas.removeEventListener('touchend', this.boundHandlers.touchEnd);
                this.canvas.removeEventListener('contextmenu', this.boundHandlers.contextMenu);
                
                document.removeEventListener('keydown', this.boundHandlers.keyDown);
            }
            
            resetDragState() {
                this.isDragging = false;
                this.draggedCards = [];
                this.dragSourceInfo = null;
                this.updateCursor();
            }
            
            updateCursor() {
                if (!this.canvas) return;
                
                if (this.isDragging) {
                    this.canvas.style.cursor = 'grabbing';
                } else if (this.game.state.hoveredCard && this.game.state.hoveredCard.faceUp && this.game.state.hoveredCard.id !== 'stock') {
                    this.canvas.style.cursor = 'pointer';
                } else if (this.game.state.hoveredCard && this.game.state.hoveredCard.id === 'stock') {
                    this.canvas.style.cursor = 'pointer';
                } else {
                    this.canvas.style.cursor = 'default';
                }
            }
            
            getMousePos(e) {
                const rect = this.canvas.getBoundingClientRect();
                return {
                    x: e.clientX - rect.left,
                    y: e.clientY - rect.top
                };
            }
            
            getTouchPos(e) {
                const rect = this.canvas.getBoundingClientRect();
                const touch = e.touches[0] || e.changedTouches[0];
                return {
                    x: touch.clientX - rect.left,
                    y: touch.clientY - rect.top
                };
            }
            
            handleKeyDown(e) {
                if (document.getElementById('gameArea').style.display === 'none') return;
                
                try {
                    switch(e.key.toLowerCase()) {
                        case 'n':
                            e.preventDefault();
                            this.game.newGame();
                            break;
                        case 'u':
                        case 'z':
                            if (e.ctrlKey || e.metaKey || e.key === 'u') {
                                e.preventDefault();
                                this.game.undo();
                            }
                            break;
                        case 'r':
                            e.preventDefault();
                            this.game.redo();
                            break;
                        case 'h':
                        case '?':
                            e.preventDefault();
                            this.game.ai.showHint();
                            break;
                        case 's':
                            if (e.ctrlKey || e.metaKey) {
                                e.preventDefault();
                                this.game.storage.quickSave();
                            }
                            break;
                        case ' ':
                        case 'enter':
                            e.preventDefault();
                            if (this.game.state.stock.length > 0 || this.game.state.waste.length > 0) {
                                this.game.ai.flipStock();
                            }
                            break;
                        case 'escape':
                            if (this.isDragging) {
                                this.resetDragState();
                                this.game.renderer.render();
                            }
                            break;
                    }
                } catch (error) {
                    console.error('Error handling keyboard input:', error);
                }
            }
            
            handleMouseDown(e) {
                if (this.game.gameWon) return;
                
                try {
                    const pos = this.getMousePos(e);
                    const cardInfo = this.game.renderer.getCardAt(pos.x, pos.y);
                    if (cardInfo) {
                        if (cardInfo.card.id === 'stock') {
                            return;
                        }
                        
                        if (cardInfo.card.faceUp) {
                            e.preventDefault();
                            this.startDrag(cardInfo, pos.x, pos.y);
                        }
                    }
                } catch (error) {
                    console.error('Error handling mouse down:', error);
                }
            }
            
            handleMouseMove(e) {
                try {
                    const pos = this.getMousePos(e);
                    
                    if (this.isDragging) {
                        this.dragCurrentPos.x = pos.x;
                        this.dragCurrentPos.y = pos.y;
                        this.game.renderer.render();
                    } else {
                        const cardInfo = this.game.renderer.getCardAt(pos.x, pos.y);
                        const newHoveredCard = cardInfo ? cardInfo.card : null;
                        if (this.game.state.hoveredCard !== newHoveredCard) {
                            this.game.state.hoveredCard = newHoveredCard;
                            this.updateCursor();
                            this.game.renderer.render();
                        }
                    }
                } catch (error) {
                    console.error('Error handling mouse move:', error);
                }
            }
            
            handleMouseUp(e) {
                if (!this.isDragging) return;
                
                try {
                    const pos = this.getMousePos(e);
                    const dropZone = this.game.renderer.getDropZoneAt(pos.x, pos.y);
                    if (dropZone && this.isValidDrop(dropZone)) {
                        this.executeDrop(dropZone);
                    }
                    
                    this.resetDragState();
                    this.game.renderer.render();
                } catch (error) {
                    console.error('Error handling mouse up:', error);
                }
            }
            
            handleCanvasClick(e) {
                if (this.isDragging) return;
                
                try {
                    const pos = this.getMousePos(e);
                    const cardInfo = this.game.renderer.getCardAt(pos.x, pos.y);
                    if (cardInfo && cardInfo.card.id === 'stock') {
                        this.game.ai.flipStock();
                    }
                } catch (error) {
                    console.error('Error handling canvas click:', error);
                }
            }
            
            handleCanvasDoubleClick(e) {
                if (this.isDragging) return;
                
                try {
                    const pos = this.getMousePos(e);
                    const cardInfo = this.game.renderer.getCardAt(pos.x, pos.y);
                    if (cardInfo && cardInfo.card.faceUp && cardInfo.card.id !== 'stock') {
                        this.game.ai.attemptAutoMove(cardInfo.card);
                    }
                } catch (error) {
                    console.error('Error handling double click:', error);
                }
            }
            
            handleMouseLeave(e) {
                this.game.state.hoveredCard = null;
                this.updateCursor();
                if (!this.isDragging) {
                    this.game.renderer.render();
                }
            }
            
            handleTouchStart(e) {
                e.preventDefault();
                
                try {
                    const pos = this.getTouchPos(e);
                    const cardInfo = this.game.renderer.getCardAt(pos.x, pos.y);
                    if (cardInfo) {
                        if (cardInfo.card.id === 'stock') {
                            this.game.haptics.cardFlip();
                            this.game.ai.flipStock();
                        } else if (cardInfo.card.faceUp) {
                            this.game.haptics.cardPlace();
                            this.startDrag(cardInfo, pos.x, pos.y);
                        }
                    }
                } catch (error) {
                    console.error('Error handling touch start:', error);
                }
            }
            
            handleTouchMove(e) {
                if (!this.isDragging) return;
                e.preventDefault();
                
                try {
                    const pos = this.getTouchPos(e);
                    this.dragCurrentPos.x = pos.x;
                    this.dragCurrentPos.y = pos.y;
                    this.game.renderer.render();
                } catch (error) {
                    console.error('Error handling touch move:', error);
                }
            }
            
            handleTouchEnd(e) {
                e.preventDefault();
                if (!this.isDragging) return;
                
                try {
                    const pos = this.getTouchPos(e);
                    const dropZone = this.game.renderer.getDropZoneAt(pos.x, pos.y);
                    if (dropZone && this.isValidDrop(dropZone)) {
                        this.game.haptics.cardPlace();
                        if (this.game.particles) {
                            this.game.particles.createCardPlaceEffect(pos.x, pos.y);
                        }
                        this.executeDrop(dropZone);
                    } else {
                        this.game.haptics.error();
                    }
                    
                    this.resetDragState();
                    this.game.renderer.render();
                } catch (error) {
                    console.error('Error handling touch end:', error);
                }
            }
            
            handleContextMenu(e) {
                e.preventDefault();
            }
            
            startDrag(cardInfo, mouseX, mouseY) {
                try {
                    const card = cardInfo.card;
                    this.dragOffset.x = mouseX - cardInfo.x;
                    this.dragOffset.y = mouseY - cardInfo.y;
                    this.dragCurrentPos.x = mouseX;
                    this.dragCurrentPos.y = mouseY;
                    
                    if (cardInfo.location === 'waste') {
                        if (this.game.state.waste.length > 0 && this.game.state.waste[this.game.state.waste.length - 1].id === card.id) {
                            this.dragSourceInfo = { type: 'waste' };
                            this.draggedCards = [card];
                        }
                    } else if (cardInfo.location === 'foundation') {
                        this.dragSourceInfo = { type: 'foundation', suit: cardInfo.suit };
                        this.draggedCards = [card];
                    } else if (cardInfo.location === 'tableau') {
                        const pile = this.game.state.tableau[cardInfo.pileIndex];
                        const cardIndex = cardInfo.cardIndex;
                        
                        this.dragSourceInfo = { type: 'tableau', pileIndex: cardInfo.pileIndex, cardIndex: cardIndex };
                        
                        if (pile[cardIndex].faceUp) {
                            this.draggedCards = pile.slice(cardIndex);
                        } else {
                            return;
                        }
                    }
                    
                    if (this.draggedCards.length > 0) {
                        this.isDragging = true;
                        this.updateCursor();
                        this.game.renderer.render();
                    }
                } catch (error) {
                    console.error('Error starting drag:', error);
                }
            }
            
            isValidDrop(dropZone) {
                try {
                    if (dropZone.type === 'foundation') {
                        return this.isValidFoundationDrop(dropZone.suit);
                    } else if (dropZone.type === 'tableau') {
                        return this.isValidTableauDrop(dropZone.pileIndex);
                    }
                    return false;
                } catch (error) {
                    console.error('Error validating drop:', error);
                    return false;
                }
            }
            
            isValidFoundationDrop(suit) {
                if (this.draggedCards.length !== 1) return false;
                const card = this.draggedCards[0];
                return card.suit === suit && this.game.rules.canPlaceOnFoundation(card);
            }
            
            isValidTableauDrop(pileIndex) {
                if (this.draggedCards.length === 0) return false;
                
                if (this.dragSourceInfo && this.dragSourceInfo.type === 'tableau' && 
                    this.dragSourceInfo.pileIndex === pileIndex) {
                    return false;
                }
                
                if (!this.game.rules.isValidSequence(this.draggedCards)) {
                    return false;
                }
                
                const topCard = this.draggedCards[0];
                return this.game.rules.canPlaceOnTableau(topCard, this.game.state.tableau[pileIndex]);
            }
            
            executeDrop(dropZone) {
                try {
                    this.game.state.saveGameState();
                    this.game.state.gameStats.moves++;
                    this.game.sound.play('cardPlace');
                    
                    let moveType = '';
                    if (dropZone.type === 'foundation') {
                        moveType = 'foundation';
                    } else if (this.dragSourceInfo.type === 'waste') {
                        moveType = 'waste_to_tableau';
                    } else if (this.dragSourceInfo.type === 'foundation') {
                        moveType = 'foundation_to_tableau';
                    } else {
                        moveType = 'tableau_to_tableau';
                    }
                    
                    let willRevealCard = false;
                    if (this.dragSourceInfo.type === 'tableau') {
                        const sourcePile = this.game.state.tableau[this.dragSourceInfo.pileIndex];
                        const remainingCards = sourcePile.length - this.draggedCards.length;
                        if (remainingCards > 0 && !sourcePile[remainingCards - 1].faceUp) {
                            willRevealCard = true;
                        }
                    }
                    
                    if (this.dragSourceInfo.type === 'waste') {
                        this.game.state.waste.pop();
                    } else if (this.dragSourceInfo.type === 'foundation') {
                        this.game.state.foundations[this.dragSourceInfo.suit].pop();
                    } else if (this.dragSourceInfo.type === 'tableau') {
                        const sourcePile = this.game.state.tableau[this.dragSourceInfo.pileIndex];
                        sourcePile.splice(this.dragSourceInfo.cardIndex);
                        
                        if (sourcePile.length > 0 && !sourcePile[sourcePile.length - 1].faceUp) {
                            sourcePile[sourcePile.length - 1].faceUp = true;
                        }
                    }
                    
                    if (dropZone.type === 'foundation') {
                        this.game.state.foundations[dropZone.suit].push(...this.draggedCards);
                    } else if (dropZone.type === 'tableau') {
                        this.game.state.tableau[dropZone.pileIndex].push(...this.draggedCards);
                    }
                    
                    this.game.state.updateScore(moveType);
                    if (willRevealCard) {
                        this.game.state.updateScore('reveal');
                    }
                    
                    this.game.state.hintCardId = null;
                    this.game.ui.updateUI();
                    
                    setTimeout(() => {
                        if (this.game.rules.checkAutoMoveToFoundation()) {
                            this.game.renderer.render();
                        }
                    }, 100);
                } catch (error) {
                    console.error('Error executing drop:', error);
                }
            }
        }

        // Render engine
        class RenderEngine {
            constructor(gameInstance) {
                this.game = gameInstance;
                this.canvas = null;
                this.ctx = null;
                this.cardPositions = new Map();
                this.validDropZones = [];
            }
            
            init() {
                this.canvas = document.getElementById('gameCanvas');
                if (!this.canvas) return false;
                
                this.ctx = this.canvas.getContext('2d');
                if (!this.ctx) return false;
                
                const rect = this.canvas.getBoundingClientRect();
                this.canvas.width = rect.width;
                this.canvas.height = rect.height;
                
                // Initialize particle system
                if (!this.game.particles) {
                    this.game.particles = new ParticleSystem(this.canvas);
                }
                
                return true;
            }
            
            render() {
                try {
                    if (!this.ctx) {
                        if (!this.init()) return;
                    }
                    
                    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                    this.cardPositions.clear();
                    this.validDropZones = [];
                    
                    this.drawStock();
                    this.drawWaste();
                    this.drawFoundations();
                    this.drawTableau();
                    this.drawDraggedCards();
                    
                    // Update and render particle effects
                    if (this.game.particles) {
                        this.game.particles.update();
                        this.game.particles.render();
                    }
                } catch (error) {
                    console.error('Error rendering game:', error);
                }
            }
            
            drawStock() {
                const stockX = 50;
                const stockY = 50;
                
                if (this.game.state.stock.length > 0) {
                    const depth = Math.min(3, this.game.state.stock.length);
                    for (let i = 0; i < depth; i++) {
                        this.drawCard({ id: 'stock', faceUp: false }, stockX - i*2, stockY - i*2, false, 0.7 + i*0.1);
                    }
                    
                    const isHovered = this.game.state.hoveredCard && this.game.state.hoveredCard.id === 'stock';
                    this.drawCard({ id: 'stock', faceUp: false }, stockX, stockY, false, 1, isHovered);
                } else {
                    this.ctx.strokeStyle = '#9ca3af';
                    this.ctx.lineWidth = 2;
                    this.ctx.setLineDash([5, 5]);
                    this.ctx.strokeRect(stockX, stockY, this.game.constants.CARD_WIDTH, this.game.constants.CARD_HEIGHT);
                    this.ctx.setLineDash([]);
                    
                    this.ctx.fillStyle = '#6b7280';
                    this.ctx.font = 'bold 20px Arial';
                    this.ctx.textAlign = 'center';
                    this.ctx.textBaseline = 'middle';
                    this.ctx.fillText('↻', stockX + this.game.constants.CARD_WIDTH/2, stockY + this.game.constants.CARD_HEIGHT/2);
                }
                
                this.cardPositions.set('stock', { 
                    x: stockX, 
                    y: stockY, 
                    card: { id: 'stock', faceUp: false }, 
                    width: this.game.constants.CARD_WIDTH, 
                    height: this.game.constants.CARD_HEIGHT,
                    location: 'stock'
                });
            }
            
            drawWaste() {
                const wasteX = 50 + this.game.constants.CARD_WIDTH + 20;
                const wasteY = 50;
                const visibleWaste = this.game.state.waste.slice(-this.game.state.drawMode);
                
                visibleWaste.forEach((card, i) => {
                    const isDraggedCard = this.game.input.isDragging && this.game.input.draggedCards.some(dc => dc.id === card.id);
                    const alpha = isDraggedCard ? 0.3 : 1;
                    const x = wasteX + i * this.game.constants.WASTE_CARD_OFFSET;
                    const y = wasteY;
                    const isHovered = this.game.state.hoveredCard && this.game.state.hoveredCard.id === card.id;
                    
                    this.drawCard(card, x, y, card.id === this.game.state.hintCardId, alpha, isHovered);
                    
                    if (alpha >= 0.5) {
                        this.cardPositions.set(card.id, { 
                            x, 
                            y, 
                            card, 
                            width: this.game.constants.CARD_WIDTH, 
                            height: this.game.constants.CARD_HEIGHT,
                            location: 'waste',
                            stackIndex: i
                        });
                    }
                });
            }
            
            drawFoundations() {
                const foundationStartX = 50 + this.game.constants.CARD_WIDTH + 20 + this.game.constants.CARD_WIDTH + 80;
                
                this.game.constants.SUITS.forEach((suit, i) => {
                    const foundationX = foundationStartX + i * (this.game.constants.CARD_WIDTH + 10);
                    const foundationY = 50;
                    const pile = this.game.state.foundations[suit];
                    
                    if (pile.length > 0) {
                        const topCard = pile[pile.length - 1];
                        const isDraggedCard = this.game.input.isDragging && this.game.input.draggedCards.some(dc => dc.id === topCard.id);
                        const alpha = isDraggedCard ? 0.3 : 1;
                        const isHovered = this.game.state.hoveredCard && this.game.state.hoveredCard.id === topCard.id;
                        
                        this.drawCard(topCard, foundationX, foundationY, topCard.id === this.game.state.hintCardId, alpha, isHovered);
                        
                        if (alpha >= 0.5) {
                            this.cardPositions.set(topCard.id, { 
                                x: foundationX, 
                                y: foundationY, 
                                card: topCard, 
                                width: this.game.constants.CARD_WIDTH, 
                                height: this.game.constants.CARD_HEIGHT,
                                location: 'foundation',
                                suit: suit
                            });
                        }
                    } else {
                        const isValidDrop = this.game.input.isDragging && this.isValidFoundationDrop(suit);
                        this.ctx.strokeStyle = isValidDrop ? '#22c55e' : '#9ca3af';
                        this.ctx.lineWidth = isValidDrop ? 4 : 2;
                        this.ctx.setLineDash([5, 5]);
                        this.ctx.strokeRect(foundationX, foundationY, this.game.constants.CARD_WIDTH, this.game.constants.CARD_HEIGHT);
                        this.ctx.setLineDash([]);
                        
                        if (isValidDrop) {
                            this.ctx.fillStyle = 'rgba(34, 197, 94, 0.2)';
                            this.ctx.fillRect(foundationX, foundationY, this.game.constants.CARD_WIDTH, this.game.constants.CARD_HEIGHT);
                        }
                        
                        this.ctx.fillStyle = isValidDrop ? '#22c55e' : '#9ca3af';
                        this.ctx.font = 'bold 32px Arial';
                        this.ctx.textAlign = 'center';
                        this.ctx.textBaseline = 'middle';
                        this.ctx.fillText(suit, foundationX + this.game.constants.CARD_WIDTH/2, foundationY + this.game.constants.CARD_HEIGHT/2);
                    }
                    
                    this.validDropZones.push({
                        type: 'foundation',
                        suit: suit,
                        x: foundationX,
                        y: foundationY,
                        width: this.game.constants.CARD_WIDTH,
                        height: this.game.constants.CARD_HEIGHT
                    });
                });
            }
            
            drawTableau() {
                const tableauStartX = 50;
                const tableauY = 50 + this.game.constants.CARD_HEIGHT + 40;
                
                this.game.state.tableau.forEach((pile, pileIndex) => {
                    const pileX = tableauStartX + pileIndex * (this.game.constants.CARD_WIDTH + 15);
                    let maxY = tableauY;
                    
                    pile.forEach((card, cardIndex) => {
                        const cardY = tableauY + cardIndex * (card.faceUp ? this.game.constants.FACE_UP_OFFSET : this.game.constants.FACE_DOWN_OFFSET);
                        const isDraggedCard = this.game.input.isDragging && this.game.input.draggedCards.some(dc => dc.id === card.id);
                        const alpha = isDraggedCard ? 0.3 : 1;
                        const isHovered = this.game.state.hoveredCard && this.game.state.hoveredCard.id === card.id;
                        
                        this.drawCard(card, pileX, cardY, card.id === this.game.state.hintCardId, alpha, isHovered);
                        maxY = cardY + this.game.constants.CARD_HEIGHT;
                        
                        if (alpha >= 0.5) {
                            this.cardPositions.set(card.id, { 
                                x: pileX, 
                                y: cardY, 
                                card, 
                                width: this.game.constants.CARD_WIDTH, 
                                height: this.game.constants.CARD_HEIGHT,
                                location: 'tableau',
                                pileIndex,
                                cardIndex
                            });
                        }
                    });
                    
                    if (pile.length === 0) {
                        const isValidDrop = this.game.input.isDragging && this.isValidTableauDrop(pileIndex);
                        this.ctx.strokeStyle = isValidDrop ? '#22c55e' : '#6b7280';
                        this.ctx.lineWidth = isValidDrop ? 4 : 2;
                        this.ctx.setLineDash([5, 5]);
                        this.ctx.strokeRect(pileX, tableauY, this.game.constants.CARD_WIDTH, this.game.constants.CARD_HEIGHT);
                        this.ctx.setLineDash([]);
                        
                        if (isValidDrop) {
                            this.ctx.fillStyle = 'rgba(34, 197, 94, 0.2)';
                            this.ctx.fillRect(pileX, tableauY, this.game.constants.CARD_WIDTH, this.game.constants.CARD_HEIGHT);
                        }
                        
                        this.ctx.fillStyle = isValidDrop ? '#22c55e' : '#6b7280';
                        this.ctx.font = 'bold 24px Arial';
                        this.ctx.textAlign = 'center';
                        this.ctx.textBaseline = 'middle';
                        this.ctx.fillText('K', pileX + this.game.constants.CARD_WIDTH/2, tableauY + this.game.constants.CARD_HEIGHT/2);
                        
                        maxY = tableauY + this.game.constants.CARD_HEIGHT;
                    }
                    
                    this.validDropZones.push({
                        type: 'tableau',
                        pileIndex: pileIndex,
                        x: pileX,
                        y: tableauY,
                        width: this.game.constants.CARD_WIDTH,
                        height: Math.max(this.game.constants.CARD_HEIGHT, maxY - tableauY)
                    });
                });
            }
            
            drawDraggedCards() {
                if (this.game.input.isDragging && this.game.input.draggedCards.length > 0) {
                    this.game.input.draggedCards.forEach((card, index) => {
                        const x = this.game.input.dragCurrentPos.x - this.game.input.dragOffset.x;
                        const y = this.game.input.dragCurrentPos.y - this.game.input.dragOffset.y + index * this.game.constants.FACE_UP_OFFSET;
                        this.drawCard(card, x, y, false, 0.9);
                    });
                }
            }
            
            drawCard(card, x, y, highlighted = false, alpha = 1, isHovered = false) {
                this.ctx.save();
                this.ctx.globalAlpha = alpha;
                
                const shadowOffset = isHovered ? 4 : 2;
                const shadowAlpha = isHovered ? 0.4 : 0.3;
                this.ctx.fillStyle = `rgba(0,0,0,${shadowAlpha})`;
                this.ctx.fillRect(x + shadowOffset, y + shadowOffset, this.game.constants.CARD_WIDTH, this.game.constants.CARD_HEIGHT);
                
                if (highlighted) {
                    this.ctx.strokeStyle = '#ffd700';
                    this.ctx.lineWidth = 4;
                    this.ctx.strokeRect(x - 2, y - 2, this.game.constants.CARD_WIDTH + 4, this.game.constants.CARD_HEIGHT + 4);
                }
                
                if (isHovered && !this.game.input.isDragging) {
                    this.ctx.strokeStyle = '#4ade80';
                    this.ctx.lineWidth = 3;
                    this.ctx.strokeRect(x - 1, y - 1, this.game.constants.CARD_WIDTH + 2, this.game.constants.CARD_HEIGHT + 2);
                }
                
                if (card.faceUp) {
                    const gradient = this.ctx.createLinearGradient(x, y, x, y + this.game.constants.CARD_HEIGHT);
                    gradient.addColorStop(0, '#ffffff');
                    gradient.addColorStop(0.1, '#f8f9fa');
                    gradient.addColorStop(0.9, '#e9ecef');
                    gradient.addColorStop(1, '#dee2e6');
                    this.ctx.fillStyle = gradient;
                } else {
                    const gradient = this.ctx.createRadialGradient(
                        x + this.game.constants.CARD_WIDTH/2, y + this.game.constants.CARD_HEIGHT/2, 0,
                        x + this.game.constants.CARD_WIDTH/2, y + this.game.constants.CARD_HEIGHT/2, Math.max(this.game.constants.CARD_WIDTH, this.game.constants.CARD_HEIGHT)/2
                    );
                    gradient.addColorStop(0, '#3b82f6');
                    gradient.addColorStop(0.7, '#2563eb');
                    gradient.addColorStop(1, '#1e40af');
                    this.ctx.fillStyle = gradient;
                }
                
                this.ctx.fillRect(x, y, this.game.constants.CARD_WIDTH, this.game.constants.CARD_HEIGHT);
                
                this.ctx.strokeStyle = isHovered ? '#22c55e' : '#374151';
                this.ctx.lineWidth = isHovered ? 2.5 : 2;
                this.ctx.strokeRect(x, y, this.game.constants.CARD_WIDTH, this.game.constants.CARD_HEIGHT);
                
                if (card.faceUp) {
                    const isRed = this.game.constants.RED_SUITS.has(card.suit);
                    this.ctx.fillStyle = isRed ? '#dc2626' : '#000000';
                    this.ctx.font = 'bold 16px Arial';
                    this.ctx.textAlign = 'left';
                    this.ctx.textBaseline = 'top';
                    
                    this.ctx.fillText(card.rank, x + 4, y + 4);
                    this.ctx.fillText(card.suit, x + 4, y + 20);
                    
                    this.ctx.save();
                    this.ctx.translate(x + this.game.constants.CARD_WIDTH - 4, y + this.game.constants.CARD_HEIGHT - 4);
                    this.ctx.rotate(Math.PI);
                    this.ctx.fillText(card.rank, 0, 0);
                    this.ctx.fillText(card.suit, 0, 16);
                    this.ctx.restore();
                    
                    this.ctx.font = 'bold 24px Arial';
                    this.ctx.textAlign = 'center';
                    this.ctx.textBaseline = 'middle';
                    
                    this.ctx.fillText(card.suit, x + this.game.constants.CARD_WIDTH/2, y + this.game.constants.CARD_HEIGHT/2);
                    
                } else {
                    this.ctx.fillStyle = '#ffffff';
                    this.ctx.globalAlpha = 0.3 * alpha;
                    
                    for (let i = 0; i < 4; i++) {
                        for (let j = 0; j < 6; j++) {
                            const patternX = x + 8 + i * 18;
                            const patternY = y + 8 + j * 18;
                            
                            this.ctx.beginPath();
                            this.ctx.arc(patternX, patternY, 4, 0, Math.PI * 2);
                            this.ctx.fill();
                            
                            this.ctx.beginPath();
                            this.ctx.arc(patternX + 9, patternY + 9, 2, 0, Math.PI * 2);
                            this.ctx.fill();
                        }
                    }
                    
                    this.ctx.strokeStyle = '#ffffff';
                    this.ctx.lineWidth = 1;
                    this.ctx.globalAlpha = 0.4 * alpha;
                    this.ctx.strokeRect(x + 6, y + 6, this.game.constants.CARD_WIDTH - 12, this.game.constants.CARD_HEIGHT - 12);
                }
                
                this.ctx.restore();
            }
            
            getCardAt(x, y) {
                let bestCard = null;
                let bestZ = -1;
                
                for (const [cardId, info] of this.cardPositions.entries()) {
                    if (x >= info.x && x < info.x + info.width && 
                        y >= info.y && y < info.y + info.height) {
                        
                        let zOrder = 0;
                        
                        if (info.location === 'stock') {
                            zOrder = 1000;
                        } else if (info.location === 'waste') {
                            zOrder = 900 + (info.stackIndex || 0);
                        } else if (info.location === 'foundation') {
                            zOrder = 800;
                        } else if (info.location === 'tableau') {
                            if (!info.card.faceUp) continue;
                            
                            zOrder = 100 + info.cardIndex;
                            const pile = this.game.state.tableau[info.pileIndex];
                            const isTopCard = info.cardIndex === pile.length - 1;
                            
                            if (isTopCard) {
                                zOrder += 100;
                            } else {
                                const nextCard = pile[info.cardIndex + 1];
                                if (nextCard) {
                                    const visibleHeight = nextCard.faceUp ? this.game.constants.FACE_UP_OFFSET : this.game.constants.FACE_DOWN_OFFSET;
                                    if (y > info.y + visibleHeight) {
                                        zOrder -= 20;
                                    }
                                }
                            }
                        }
                        
                        if (zOrder > bestZ) {
                            bestZ = zOrder;
                            bestCard = info;
                        }
                    }
                }
                
                return bestCard;
            }
            
            getDropZoneAt(x, y) {
                for (const zone of this.validDropZones) {
                    if (x >= zone.x && x < zone.x + zone.width &&
                        y >= zone.y && y < zone.y + zone.height) {
                        return zone;
                    }
                }
                return null;
            }
            
            isValidFoundationDrop(suit) {
                return this.game.input.isValidFoundationDrop(suit);
            }
            
            isValidTableauDrop(pileIndex) {
                return this.game.input.isValidTableauDrop(pileIndex);
            }
        }

        // Advanced Intelligent ML Manager with Complete Board Vision and Learning
        class MLManager {
            constructor(gameInstance) {
                this.game = gameInstance;
                this.isInitialized = false;
                this.isDisposed = false;
                this.fallbackMode = false;
                
                class LearningDB {
                  constructor() {
                   this.dbPromise = new Promise((resolve, reject) => {
                      const req = indexedDB.open('KlondikeLearning', 1);
                      req.onupgradeneeded = (event) => {
                         const db = event.target.result;
                         if (!db.objectStoreNames.contains('games')) {
                           db.createObjectStore('games', { keyPath: 'timestamp' });
                     }
                 };
                 req.onsuccess = () => resolve(req.result);
                  req.onerror = () => reject(req.error);
                 });
             }

                  async saveGameRecord(gameRecord) {
                     const db = await this.dbPromise;
                     const tx = db.transaction('games', 'readwrite');
                      tx.objectStore('games').put(gameRecord);
                      return tx.complete;
                  }

                 async getAllGameRecords() {
                     const db = await this.dbPromise;
                     const tx = db.transaction('games', 'readonly');
                      return tx.objectStore('games').getAll();
                 }
            }


                // Advanced learning and memory systems
                this.gameMemory = {
                    winningGames: [], // Complete games that resulted in wins
                    losingGames: [], // Games that were lost or abandoned
                    moveOutcomes: new Map(), // Move -> success rate mapping
                    positionEvaluations: new Map(), // Game state -> win probability
                    sequencePatterns: new Map(), // Successful move sequences
                    cardMemory: new Map(), // Hidden card location tracking
                    stockDrawingPatterns: new Map() // Optimal stock drawing strategies
                };
                
                // Neural network simulation with weights
                this.neuralWeights = {
                    foundationValue: 10.0,
                    sequenceValue: 8.0,
                    revealValue: 7.0,
                    emptySpaceValue: 6.0,
                    kingPlacementValue: 5.0,
                    stockEfficiency: 4.0,
                    riskMitigation: 3.0
                };
                
                // Complete board vision tracking
                this.completeBoard = {
                    allCards: new Map(), // cardId -> current location and properties
                    hiddenCards: new Map(), // location -> card for face-down cards
                    stockOrder: [], // exact order of cards in stock
                    futureStockCards: [] // cards that will come up in stock
                };
                
                // Web AI integration capabilities
                this.webAIEnabled = false;
                this.lastWebAIQuery = 0;
                this.webAICache = new Map();
                
                this.initializeAdvancedAI();
            }
            
            async initializeAdvancedAI() {
                try {
                    this.isInitialized = true;
                    
                    // Load existing learning data
                    await this.loadLearningData();
                    
                    // Initialize complete board tracking
                    this.initializeCompleteBoard();
                    
                    // Check for web AI capabilities
                    this.checkWebAIAvailability();
                    
                    console.log('🧠 Advanced AI System initialized with complete board vision and learning');
                    console.log(`📚 Loaded: ${this.gameMemory.winningGames.length} winning games, ${this.gameMemory.moveOutcomes.size} move patterns`);
                    
                    // Show initialization status
                    setTimeout(() => {
                        if (this.game.ui) {
                            this.game.ui.showNotification(
                                `🧠 Advanced AI Online! Features: Complete board vision, learning from ${this.gameMemory.winningGames.length} wins, strategic analysis`,
                                'info', 4000
                            );
                        }
                    }, 2000);
                    
                } catch (error) {
                    console.warn('Advanced AI initialization failed, using enhanced mode:', error);
                    this.fallbackMode = true;
                    this.isInitialized = true;
                }
            }
            
            initializeCompleteBoard() {
                // Initialize tracking for all cards in the deck
                this.game.constants.SUITS.forEach(suit => {
                    this.game.constants.RANKS.forEach((rank, index) => {
                        const cardId = `${rank}${suit}`;
                        this.completeBoard.allCards.set(cardId, {
                            id: cardId,
                            suit: suit,
                            rank: rank,
                            value: index + 1,
                            location: 'unknown',
                            visible: false,
                            strategic_value: this.calculateCardStrategicValue(suit, index + 1)
                        });
                    });
                });
            }
            
            // Update complete board vision when game state changes
            updateCompleteBoard(gameState) {
                // Clear current tracking
                this.completeBoard.allCards.forEach(card => {
                    card.location = 'unknown';
                    card.visible = false;
                });
                
                // Track visible cards
                gameState.waste.forEach((card, index) => {
                    const cardInfo = this.completeBoard.allCards.get(card.id);
                    if (cardInfo) {
                        cardInfo.location = 'waste';
                        cardInfo.position = index;
                        cardInfo.visible = true;
                    }
                });
                
                Object.entries(gameState.foundations).forEach(([suit, pile]) => {
                    pile.forEach((card, index) => {
                        const cardInfo = this.completeBoard.allCards.get(card.id);
                        if (cardInfo) {
                            cardInfo.location = `foundation-${suit}`;
                            cardInfo.position = index;
                            cardInfo.visible = true;
                        }
                    });
                });
                
                gameState.tableau.forEach((pile, pileIndex) => {
                    pile.forEach((card, cardIndex) => {
                        const cardInfo = this.completeBoard.allCards.get(card.id);
                        if (cardInfo) {
                            cardInfo.location = `tableau-${pileIndex}`;
                            cardInfo.position = cardIndex;
                            cardInfo.visible = card.faceUp;
                            cardInfo.faceUp = card.faceUp;
                            
                            // AI can "see" face-down cards for strategic planning
                            if (!card.faceUp) {
                                this.completeBoard.hiddenCards.set(`tableau-${pileIndex}-${cardIndex}`, card);
                            }
                        }
                    });
                });
                
                // Track stock cards (AI knows the order)
                this.completeBoard.stockOrder = [...gameState.stock];
                this.completeBoard.futureStockCards = gameState.stock.slice(-6); // Next 6 cards
            }
            
            calculateCardStrategicValue(suit, value) {
                let strategicValue = value;
                
                // Aces are highly valuable
                if (value === 1) strategicValue += 10;
                
                // Kings are valuable for empty spaces
                if (value === 13) strategicValue += 5;
                
                // Face cards have higher value
                if (value >= 11) strategicValue += 3;
                
                // Red and black suit balance
                const isRed = this.game.constants.RED_SUITS.has(suit);
                strategicValue += isRed ? 1 : 2; // Slight preference for black cards
                
                return strategicValue;
            }
            
            // Memory-optimized advanced move evaluation with complete board knowledge
            async evaluateMove(move, gameState) {
                // Acquire evaluation object from memory pool
                const evaluation = this.game.memory.acquireMoveEvaluation();
                
                try {
                    this.updateCompleteBoard(gameState);
                    
                    // Cache game state for repeated analysis
                    const stateKey = this.hashGameState(gameState);
                    let cachedState = this.game.memory.getCachedGameState(stateKey);
                    if (!cachedState) {
                        cachedState = gameState;
                        this.game.memory.cacheGameState(stateKey, gameState);
                    }
                    
                    let score = 0;
                    let confidence = 0.5;
                    evaluation.strategicReasoning.length = 0; // Reset array
                    
                    // Base move value
                    score += move.priority || 0;
                    
                    // Foundation moves are always valuable
                    if (move.type === 'foundation') {
                        score += this.neuralWeights.foundationValue;
                        confidence += 0.3;
                        evaluation.strategicReasoning.push('Foundation building increases win probability');
                        
                        // Bonus for balanced foundation building
                        const foundations = Object.values(cachedState.foundations);
                        const heights = foundations.map(pile => pile.length);
                        const maxHeight = Math.max(...heights);
                        const minHeight = Math.min(...heights);
                        if (maxHeight - minHeight <= 2) {
                            score += 3;
                            evaluation.strategicReasoning.push('Maintains balanced foundation building');
                        }
                    }
                    
                    // Sequence building evaluation with lookahead
                    if (move.type === 'tableau' || move.type === 'waste-to-tableau') {
                        const sequenceValue = this.evaluateSequenceBuilding(move, cachedState);
                        score += sequenceValue * this.neuralWeights.sequenceValue;
                        if (sequenceValue > 0.5) {
                            confidence += 0.2;
                            evaluation.strategicReasoning.push('Creates beneficial card sequences');
                        }
                    }
                    
                    // Card reveal evaluation with hidden knowledge
                    const revealValue = this.evaluateCardReveal(move, cachedState);
                    if (revealValue > 0) {
                        score += revealValue * this.neuralWeights.revealValue;
                        confidence += 0.15;
                        evaluation.strategicReasoning.push(`Will reveal ${revealValue > 5 ? 'high-value' : 'useful'} hidden card`);
                    }
                    
                    // Empty space utilization
                    const emptySpaceValue = this.evaluateEmptySpaceUse(move, cachedState);
                    if (emptySpaceValue > 0) {
                        score += emptySpaceValue * this.neuralWeights.emptySpaceValue;
                        evaluation.strategicReasoning.push('Optimizes empty space usage');
                    }
                    
                    // Risk assessment with complete board vision
                    const riskAssessment = this.assessMoveRisk(move, cachedState);
                    score -= riskAssessment.risk * this.neuralWeights.riskMitigation;
                    if (riskAssessment.risk > 0.3) {
                        confidence -= 0.1;
                        evaluation.strategicReasoning.push(`Risk: ${riskAssessment.reason}`);
                    }
                    
                    // Learning from historical data
                    const historicalValue = this.getHistoricalMoveValue(move, cachedState);
                    score += historicalValue * 2;
                    if (historicalValue > 0.5) {
                        confidence += 0.1;
                        evaluation.strategicReasoning.push('Historically successful move pattern');
                    }
                    
                    // Future planning with stock knowledge
                    const futureValue = this.evaluateFuturePlanning(move, cachedState);
                    score += futureValue;
                    
                    // Store metadata for debugging
                    evaluation.metadata.set('cacheHit', cachedState !== gameState);
                    evaluation.metadata.set('totalCalculations', evaluation.strategicReasoning.length);
                    evaluation.metadata.set('poolUsage', this.game.memory.getMemoryStats().hitRate);
                    
                    // Populate evaluation
                    evaluation.move = move;
                    evaluation.aiScore = Math.max(0, score);
                    evaluation.confidence = Math.min(0.95, confidence);
                    evaluation.riskAssessment = riskAssessment;
                    evaluation.historicalValue = historicalValue;
                    evaluation.futurePlanning = futureValue;
                    
                    // Return optimized result
                    return {
                        ...move,
                        aiScore: evaluation.aiScore,
                        confidence: evaluation.confidence,
                        strategicReasoning: [...evaluation.strategicReasoning], // Copy array
                        futureValue: evaluation.futurePlanning,
                        riskAssessment: { ...evaluation.riskAssessment } // Copy object
                    };
                    
                } finally {
                    // Always release evaluation back to pool
                    this.game.memory.releaseMoveEvaluation(evaluation);
                }
            }
            
            evaluateSequenceBuilding(move, gameState) {
                let value = 0;
                
                if (move.card) {
                    // Check if this move creates or extends valuable sequences
                    const cardValue = move.card.value;
                    const cardSuit = move.card.suit;
                    const isRed = this.game.constants.RED_SUITS.has(cardSuit);
                    
                    // Look for cards that can build on this move
                    for (const [cardId, cardInfo] of this.completeBoard.allCards.entries()) {
                        if (cardInfo.value === cardValue - 1 && 
                            this.game.constants.RED_SUITS.has(cardInfo.suit) !== isRed) {
                            if (cardInfo.visible || this.canRevealSoon(cardInfo)) {
                                value += 2;
                            }
                        }
                    }
                    
                    // Check for long sequence potential
                    let sequenceLength = 1;
                    for (let i = 1; i < 7; i++) {
                        const nextValue = cardValue - i;
                        if (nextValue < 1) break;
                        
                        const hasNextCard = Array.from(this.completeBoard.allCards.values()).some(card => 
                            card.value === nextValue && 
                            this.game.constants.RED_SUITS.has(card.suit) !== isRed &&
                            (card.visible || this.canRevealSoon(card))
                        );
                        
                        if (hasNextCard) {
                            sequenceLength++;
                            value += 1;
                        } else {
                            break;
                        }
                    }
                    
                    // Bonus for long sequences
                    if (sequenceLength >= 4) value += 3;
                    if (sequenceLength >= 6) value += 5;
                }
                
                return value;
            }
            
            evaluateCardReveal(move, gameState) {
                let value = 0;
                
                try {
                    // Check if this move will reveal a hidden card
                    if (move && move.card && (move.type === 'tableau' || move.type === 'foundation')) {
                        const cardLocation = this.game.cards.findCardLocation(move.card);
                        if (cardLocation && cardLocation.type === 'tableau' && 
                            gameState && gameState.tableau && gameState.tableau[cardLocation.pileIndex]) {
                            const pile = gameState.tableau[cardLocation.pileIndex];
                            const cardIndex = cardLocation.cardIndex;
                            
                            if (cardIndex > 0 && pile && pile[cardIndex - 1] && !pile[cardIndex - 1].faceUp) {
                                const hiddenCard = pile[cardIndex - 1];
                                
                                // AI knows what the hidden card is
                                value += hiddenCard.value || 0; // Base value
                                
                                // Bonus for high-value cards
                                if (hiddenCard.value === 1) value += 8; // Aces
                                if (hiddenCard.value === 13) value += 6; // Kings
                                if (hiddenCard.value >= 11) value += 4; // Face cards
                                
                                // Check if revealed card will create immediate opportunities
                                const immediateUse = this.canUseCardImmediately(hiddenCard, gameState);
                                if (immediateUse) value += 5;
                            }
                        }
                    }
                } catch (error) {
                    console.warn('Error evaluating card reveal:', error);
                }
                
                return value;
            }
            
            evaluateEmptySpaceUse(move, gameState) {
                let value = 0;
                
                if (move.type === 'tableau' && move.targetPileIndex !== undefined) {
                    const targetPile = gameState.tableau[move.targetPileIndex];
                    if (targetPile.length === 0 && move.card && move.card.value === 13) {
                        // King to empty space
                        value = 3;
                        
                        // Check if this king placement unlocks valuable cards
                        const sourceLocation = this.game.cards.findCardLocation(move.card);
                        if (sourceLocation && sourceLocation.type === 'tableau') {
                            const sourcePile = gameState.tableau[sourceLocation.pileIndex];
                            const unlockedCards = sourcePile.slice(0, sourceLocation.cardIndex);
                            value += unlockedCards.filter(card => !card.faceUp).length * 2;
                        }
                    }
                }
                
                return value;
            }
            
            assessMoveRisk(move, gameState) {
                let risk = 0;
                let reason = '';
                
                try {
                    // Risk of moving from foundation
                    if (move.type === 'foundation-to-tableau') {
                        risk += 0.4;
                        reason = 'Moving from foundation is risky';
                    }
                    
                    // Risk of placing King on empty space without good reason
                    if (move.card && move.card.value === 13 && move.type === 'tableau' && 
                        typeof move.targetPileIndex === 'number' && 
                        gameState.tableau && gameState.tableau[move.targetPileIndex]) {
                        const targetPile = gameState.tableau[move.targetPileIndex];
                        if (targetPile && targetPile.length === 0) {
                            const emptySpaces = gameState.tableau.filter(pile => pile && pile.length === 0).length;
                            if (emptySpaces === 1) { // Last empty space
                                risk += 0.3;
                                reason = 'Using last empty space without clear benefit';
                            }
                        }
                    }
                    
                    // Risk assessment based on game progress
                    if (gameState.foundations) {
                        const foundationProgress = Object.values(gameState.foundations).reduce((sum, pile) => sum + (pile ? pile.length : 0), 0) / 52;
                        if (foundationProgress < 0.3 && move.type === 'foundation-to-tableau') {
                            risk += 0.5;
                            reason = 'Too early to move from foundation';
                        }
                    }
                } catch (error) {
                    console.warn('Error in risk assessment:', error);
                    risk = 0.5; // Default moderate risk
                    reason = 'Unable to assess risk';
                }
                
                return { risk, reason };
            }
            
            getHistoricalMoveValue(move, gameState) {
                const gameStateHash = this.hashGameState(gameState);
                const movePattern = `${move.type}-${move.card?.value}-${move.card?.suit}`;
                
                // Check if this move pattern has been successful before
                if (this.gameMemory.moveOutcomes.has(movePattern)) {
                    const outcome = this.gameMemory.moveOutcomes.get(movePattern);
                    return outcome.successRate || 0;
                }
                
                // Check similar game states
                for (const [stateHash, evaluation] of this.gameMemory.positionEvaluations.entries()) {
                    if (this.calculateStateSimilarity(gameStateHash, stateHash) > 0.8) {
                        return evaluation.bestMoveValue || 0;
                    }
                }
                
                return 0;
            }
            
            evaluateFuturePlanning(move, gameState) {
                let value = 0;
                
                try {
                    // Use stock knowledge to plan ahead
                    if (this.completeBoard && this.completeBoard.futureStockCards) {
                        const upcomingCards = this.completeBoard.futureStockCards;
                        
                        upcomingCards.forEach((card, index) => {
                            // Check if this move sets up future opportunities
                            if (this.moveCreatesOpportunityFor && this.moveCreatesOpportunityFor(move, card)) {
                                value += (6 - index) * 0.5; // Earlier cards are more valuable
                            }
                        });
                    }
                } catch (error) {
                    console.warn('Error in future planning evaluation:', error);
                }
                
                return value;
            }
            
            moveCreatesOpportunityFor(move, card) {
                // Simple check if a move creates opportunities for a future card
                try {
                    if (!move || !card) return false;
                    
                    // If move reveals a space, check if the card could use it
                    if (move.willReveal && card.value === 13) {
                        return true; // King can use revealed space
                    }
                    
                    // If move to foundation, it might clear space for the card
                    if (move.type === 'foundation' && card.value <= 11) {
                        return true; // Provides tableau space
                    }
                    
                    return false;
                } catch (error) {
                    return false;
                }
            }
            
            canUseCardImmediately(card, gameState) {
                try {
                    if (!card || !gameState) return false;
                    
                    // Check if card can go to foundation
                    if (gameState.foundations && gameState.foundations[card.suit]) {
                        const foundation = gameState.foundations[card.suit];
                        if (foundation.length === 0 && card.value === 1) return true; // Ace
                        if (foundation.length > 0 && foundation[foundation.length - 1].value === card.value - 1) return true;
                    }
                    
                    // Check if card can go to tableau
                    if (gameState.tableau) {
                        for (const pile of gameState.tableau) {
                            if (pile.length === 0 && card.value === 13) return true; // King on empty
                            if (pile.length > 0) {
                                const topCard = pile[pile.length - 1];
                                if (topCard.faceUp && topCard.value === card.value + 1) {
                                    // Check color alternation
                                    const isRedCard = card.suit === '♥' || card.suit === '♦';
                                    const isTopRed = topCard.suit === '♥' || topCard.suit === '♦';
                                    if (isRedCard !== isTopRed) return true;
                                }
                            }
                        }
                    }
                    
                    return false;
                } catch (error) {
                    return false;
                }
            }
            
            helpsFoundationBuilding(card, gameState) {
                try {
                    if (!card || !gameState || !gameState.foundations) return false;
                    
                    // Check if this card can go directly to foundation
                    const foundation = gameState.foundations[card.suit];
                    if (!foundation) return false;
                    
                    if (foundation.length === 0 && card.value === 1) return true; // Ace
                    if (foundation.length > 0 && foundation[foundation.length - 1].value === card.value - 1) return true;
                    
                    return false;
                } catch (error) {
                    return false;
                }
            }
            
            // Stock drawing recommendation system
            async recommendStockDrawing(gameState) {
                this.updateCompleteBoard(gameState);
                
                if (gameState.stock.length === 0) {
                    return {
                        shouldDraw: false,
                        reason: 'Stock is empty',
                        recommendation: 'Cycle through waste pile or focus on tableau moves'
                    };
                }
                
                const upcomingCards = this.completeBoard && this.completeBoard.futureStockCards ? 
                    this.completeBoard.futureStockCards : [];
                const currentMoves = this.game.ai.findAllPossibleMoves();
                
                // Analyze next few stock cards
                let drawValue = 0;
                let immediateUseCards = 0;
                let valuableCards = 0;
                
                if (upcomingCards.length > 0) {
                    upcomingCards.slice(0, gameState.drawMode || 1).forEach(card => {
                        // Check if card can be used immediately
                        if (this.canUseCardImmediately && this.canUseCardImmediately(card, gameState)) {
                            immediateUseCards++;
                            drawValue += 5;
                        }
                        
                        // Check strategic value
                        if (card.value === 1 || card.value === 13 || card.value >= 11) {
                            valuableCards++;
                            drawValue += 2;
                        }
                        
                        // Check if card helps with foundation building
                        if (this.helpsFoundationBuilding && this.helpsFoundationBuilding(card, gameState)) {
                            drawValue += 3;
                        }
                    });
                }
                
                // Decision logic
                let shouldDraw = false;
                let reason = '';
                
                if (currentMoves.length === 0) {
                    shouldDraw = true;
                    reason = 'No current moves available';
                } else if (immediateUseCards > 0) {
                    shouldDraw = true;
                    reason = `${immediateUseCards} immediately useful card(s) coming up`;
                } else if (drawValue >= 5) {
                    shouldDraw = true;
                    reason = `${valuableCards} valuable card(s) in next draw`;
                } else if (currentMoves.length < 2 && drawValue >= 3) {
                    shouldDraw = true;
                    reason = 'Limited current options, decent cards coming';
                } else {
                    shouldDraw = false;
                    reason = 'Better to play current available moves first';
                }
                
                return {
                    shouldDraw,
                    reason,
                    drawValue,
                    immediateUseCards,
                    valuableCards,
                    upcomingCards: upcomingCards.length > 0 ? 
                        upcomingCards.slice(0, gameState.drawMode || 1).map(card => `${card.rank}${card.suit}`) : [],
                    recommendation: shouldDraw ? 
                        `Draw ${gameState.drawMode} card(s) from stock` : 
                        'Focus on tableau moves first'
                };
            }
            
            // Web AI integration for enhanced intelligence
            async consultWebAI(gameState, question) {
                if (!this.webAIEnabled || Date.now() - this.lastWebAIQuery < 5000) {
                    return null; // Rate limiting
                }
                
                try {
                    const cacheKey = this.hashGameState(gameState) + question;
                    if (this.webAICache.has(cacheKey)) {
                        return this.webAICache.get(cacheKey);
                    }
                    
                    // Prepare game state for web AI
                    const gameDescription = this.prepareGameStateForWebAI(gameState);
                    
                    // This would connect to external AI services
                    // For now, we'll simulate advanced analysis
                    const webAIResponse = await this.simulateWebAIResponse(gameDescription, question);
                    
                    this.webAICache.set(cacheKey, webAIResponse);
                    this.lastWebAIQuery = Date.now();
                    
                    return webAIResponse;
                } catch (error) {
                    console.warn('Web AI consultation failed:', error);
                    return null;
                }
            }
            
            prepareGameStateForWebAI(gameState) {
                return {
                    foundations: Object.entries(gameState.foundations).map(([suit, pile]) => ({
                        suit,
                        count: pile.length,
                        nextNeeded: pile.length + 1
                    })),
                    tableau: gameState.tableau.map((pile, index) => ({
                        pileIndex: index,
                        totalCards: pile.length,
                        faceUpCards: pile.filter(c => c.faceUp).length,
                        topCard: pile.length > 0 ? `${pile[pile.length - 1].rank}${pile[pile.length - 1].suit}` : null,
                        isEmpty: pile.length === 0
                    })),
                    stock: {
                        remaining: gameState.stock.length,
                        drawMode: gameState.drawMode
                    },
                    waste: {
                        count: gameState.waste.length,
                        topCard: gameState.waste.length > 0 ? 
                            `${gameState.waste[gameState.waste.length - 1].rank}${gameState.waste[gameState.waste.length - 1].suit}` : null
                    },
                    gameStats: gameState.gameStats
                };
            }
            
            async simulateWebAIResponse(gameDescription, question) {
                // Simulate advanced AI analysis
                await new Promise(resolve => setTimeout(resolve, 100));
                
                return {
                    confidence: 0.85,
                    recommendation: 'Focus on foundation building while maintaining tableau flexibility',
                    strategicInsights: [
                        'Prioritize revealing face-down cards',
                        'Maintain color balance in tableau sequences',
                        'Use empty spaces strategically for Kings'
                    ],
                    riskAssessment: 'Low risk - good position for steady progress'
                };
            }
            
            checkWebAIAvailability() {
                // Check if we can connect to external AI services
                this.webAIEnabled = false; // Disabled by default for privacy
                
                // Could enable this if user opts in and API keys are available
                if (localStorage.getItem('enableWebAI') === 'true') {
                    this.webAIEnabled = true;
                    console.log('🌐 Web AI integration enabled');
                }
            }
            
            // Memory-optimized learning system - record game outcomes
            recordGameOutcome(gameState, moves, won, additionalData = null) {
                try {
                    if (!gameState) {
                        console.warn('Cannot record game outcome - no game state provided');
                        return;
                    }
                    
                    // Use memory manager for efficient game record creation
                    const compressedState = this.game.memory.compressGameState(gameState);
                
                const gameRecord = {
                    gameState: compressedState, // Store compressed state
                    moves: [...moves],
                    won: won,
                    timestamp: Date.now(),
                    difficulty: this.calculateGameDifficulty(gameState),
                    finalScore: gameState.gameStats.score,
                    totalTime: gameState.gameStats.time,
                    totalMoves: gameState.gameStats.moves,
                    additionalData: additionalData
                };
                
                // Store deadlock analysis for UI display
                if (additionalData && additionalData.reason === 'deadlock') {
                    this.lastDeadlockAnalysis = additionalData.analysis;
                    
                    // Record as a special category for learning
                    if (!this.gameMemory.deadlockGames) {
                        this.gameMemory.deadlockGames = [];
                    }
                    this.gameMemory.deadlockGames.push(gameRecord);
                    
                    // Learn from deadlock patterns using memory manager
                    this.recordDeadlockPatterns(gameRecord);
                    
                    // Limit deadlock memory
                    if (this.gameMemory.deadlockGames.length > 30) {
                        this.gameMemory.deadlockGames.shift();
                    }
                }
                
                if (won) {
                    this.gameMemory.winningGames.push(gameRecord);
                    
                    // Update neural weights based on successful strategies
                    this.updateNeuralWeights(gameRecord);
                    
                    // Record successful move patterns with memory optimization
                    this.recordSuccessfulMovesOptimized(moves);
                    
                    // Limit memory size
                    if (this.gameMemory.winningGames.length > 50) { // Reduced from 100 for memory efficiency
                        this.gameMemory.winningGames.shift();
                    }
                } else {
                    if (!this.gameMemory.losingGames) this.gameMemory.losingGames = [];
                    this.gameMemory.losingGames.push(gameRecord);
                    
                    // Learn from failures too
                    this.recordFailedMovesOptimized(moves);
                    
                    if (this.gameMemory.losingGames.length > 25) { // Reduced for memory efficiency
                        this.gameMemory.losingGames.shift();
                    }
                }
                
                // Use memory manager for move history tracking
                this.game.memory.moveHistory.push({
                    outcome: won ? 'win' : (additionalData?.reason === 'deadlock' ? 'deadlock' : 'loss'),
                    totalMoves: gameState.gameStats.moves,
                    finalScore: gameState.gameStats.score,
                    timestamp: Date.now()
                });
                
                // Asynchronous save to prevent blocking
                setTimeout(() => this.saveLearningData(), 100);
                
                const gameType = additionalData?.reason === 'deadlock' ? 'deadlocked' : (won ? 'winning' : 'losing');
                console.log(`🧠 Recorded ${gameType} game (optimized). Memory stats: Pool hit rate ${this.game.memory.getMemoryStats().hitRate}%, Cache size: ${this.game.memory.getMemoryStats().cacheSize}`);
                } catch (error) {
                    console.error('Error recording game outcome:', error);
                }
            }
            
            // Memory-optimized move recording
            recordSuccessfulMovesOptimized(moves) {
                moves.forEach(move => {
                    const pattern = this.createMovePattern(move);
                    this.game.memory.storePattern(pattern, true); // Success = true
                    
                    // Update traditional move outcomes too
                    const patternKey = `${move.type}-${move.card?.value}-${move.card?.suit}`;
                    if (!this.gameMemory.moveOutcomes.has(patternKey)) {
                        this.gameMemory.moveOutcomes.set(patternKey, {
                            successes: 0,
                            failures: 0,
                            successRate: 0
                        });
                    }
                    
                    const outcome = this.gameMemory.moveOutcomes.get(patternKey);
                    outcome.successes++;
                    outcome.successRate = outcome.successes / (outcome.successes + outcome.failures);
                });
            }
            
            recordFailedMovesOptimized(moves) {
                moves.forEach(move => {
                    const pattern = this.createMovePattern(move);
                    this.game.memory.storePattern(pattern, false); // Success = false
                    
                    // Update traditional move outcomes too
                    const patternKey = `${move.type}-${move.card?.value}-${move.card?.suit}`;
                    if (!this.gameMemory.moveOutcomes.has(patternKey)) {
                        this.gameMemory.moveOutcomes.set(patternKey, {
                            successes: 0,
                            failures: 0,
                            successRate: 0
                        });
                    }
                    
                    const outcome = this.gameMemory.moveOutcomes.get(patternKey);
                    outcome.failures++;
                    outcome.successRate = outcome.successes / (outcome.successes + outcome.failures);
                });
            }
            
            createMovePattern(move) {
                return {
                    type: move.type,
                    cardValue: move.card?.value || 0,
                    cardSuit: move.card?.suit || '',
                    targetType: move.targetType || '',
                    timestamp: Date.now()
                };
            }
            
            recordDeadlockPatterns(gameRecord) {
                try {
                    const analysis = gameRecord.additionalData.analysis;
                    
                    // Record common deadlock patterns for future detection
                    if (!this.gameMemory.deadlockPatterns) {
                        this.gameMemory.deadlockPatterns = {
                            excessiveStockCycling: 0,
                            suboptimalMidGame: 0,
                            unfavorableDeal: 0,
                            stockCycleThresholds: []
                        };
                    }
                    
                    // Track pattern frequencies
                    if (analysis.primaryCause === 'excessive_stock_cycling') {
                        this.gameMemory.deadlockPatterns.excessiveStockCycling++;
                        this.gameMemory.deadlockPatterns.stockCycleThresholds.push(analysis.stockCycles);
                    } else if (analysis.primaryCause === 'suboptimal_mid_game_decisions') {
                        this.gameMemory.deadlockPatterns.suboptimalMidGame++;
                    } else if (analysis.primaryCause === 'unfavorable_initial_deal') {
                        this.gameMemory.deadlockPatterns.unfavorableDeal++;
                    }
                    
                    // Learn optimal stock cycle limits
                    if (this.gameMemory.deadlockPatterns.stockCycleThresholds.length > 10) {
                        this.gameMemory.deadlockPatterns.stockCycleThresholds.shift();
                    }
                    
                    console.log('🧠 Recorded deadlock pattern for future prevention');
                } catch (error) {
                    console.warn('Error recording deadlock pattern:', error);
                }
            }
            
            updateNeuralWeights(winningGame) {
                // Analyze successful game for weight adjustments
                const moves = winningGame.moves;
                const foundationMoves = moves.filter(m => m.type === 'foundation').length;
                const sequenceMoves = moves.filter(m => m.type === 'tableau').length;
                const revealMoves = moves.filter(m => m.willReveal).length;
                
                // Adjust weights based on successful strategies
                if (foundationMoves / moves.length > 0.4) {
                    this.neuralWeights.foundationValue *= 1.05;
                }
                if (sequenceMoves / moves.length > 0.3) {
                    this.neuralWeights.sequenceValue *= 1.03;
                }
                if (revealMoves / moves.length > 0.2) {
                    this.neuralWeights.revealValue *= 1.02;
                }
                
                // Normalize weights to prevent runaway growth
                const totalWeight = Object.values(this.neuralWeights).reduce((sum, w) => sum + w, 0);
                if (totalWeight > 60) {
                    Object.keys(this.neuralWeights).forEach(key => {
                        this.neuralWeights[key] *= 0.95;
                    });
                }
            }
            
            recordSuccessfulMoves(moves) {
                moves.forEach(move => {
                    const pattern = `${move.type}-${move.card?.value}-${move.card?.suit}`;
                    
                    if (!this.gameMemory.moveOutcomes.has(pattern)) {
                        this.gameMemory.moveOutcomes.set(pattern, {
                            successes: 0,
                            failures: 0,
                            successRate: 0
                        });
                    }
                    
                    const outcome = this.gameMemory.moveOutcomes.get(pattern);
                    outcome.successes++;
                    outcome.successRate = outcome.successes / (outcome.successes + outcome.failures);
                    
                    // Record move sequences
                    if (moves.length >= 3) {
                        const sequence = moves.slice(0, 3).map(m => `${m.type}-${m.card?.value}`).join('->');
                        if (!this.gameMemory.sequencePatterns.has(sequence)) {
                            this.gameMemory.sequencePatterns.set(sequence, 0);
                        }
                        this.gameMemory.sequencePatterns.set(sequence, this.gameMemory.sequencePatterns.get(sequence) + 1);
                    }
                });
            }
            
            recordFailedMoves(moves) {
                moves.forEach(move => {
                    const pattern = `${move.type}-${move.card?.value}-${move.card?.suit}`;
                    
                    if (!this.gameMemory.moveOutcomes.has(pattern)) {
                        this.gameMemory.moveOutcomes.set(pattern, {
                            successes: 0,
                            failures: 0,
                            successRate: 0
                        });
                    }
                    
                    const outcome = this.gameMemory.moveOutcomes.get(pattern);
                    outcome.failures++;
                    outcome.successRate = outcome.successes / (outcome.successes + outcome.failures);
                });
            }
            
            // Enhanced game analysis with complete intelligence
            async getGameAnalysis(gameState) {
                try {
                    this.updateCompleteBoard(gameState);
                    
                    // Multi-layered analysis
                    const basicAnalysis = this.performBasicAnalysis(gameState);
                    const strategicAnalysis = this.performStrategicAnalysis(gameState);
                    const learningAnalysis = this.performLearningAnalysis(gameState);
                    const stockAnalysis = await this.recommendStockDrawing(gameState);
                    
                    // Web AI consultation if enabled
                    let webAIInsights = null;
                    if (this.webAIEnabled) {
                        webAIInsights = await this.consultWebAI(gameState, 'strategic_analysis');
                    }
                    
                    return {
                        winProbability: this.calculateWinProbability(gameState, strategicAnalysis),
                        difficulty: strategicAnalysis.difficulty,
                        recommendation: this.generateAdvancedRecommendation(basicAnalysis, strategicAnalysis, learningAnalysis),
                        stockRecommendation: stockAnalysis,
                        strategicInsights: strategicAnalysis.insights,
                        hiddenCardInsights: this.analyzeHiddenCards(gameState),
                        learningInsights: learningAnalysis,
                        webAIInsights: webAIInsights,
                        neuralWeights: { ...this.neuralWeights }
                    };
                } catch (error) {
                    console.error('Advanced game analysis error:', error);
                    return this.getFallbackAnalysis(gameState);
                }
            }
            
            performBasicAnalysis(gameState) {
                try {
                    if (!gameState) {
                        return {
                            foundationProgress: 0,
                            faceUpCards: 0,
                            emptySpaces: 0,
                            blockedCards: 0,
                            stockRemaining: 0,
                            wasteSize: 0
                        };
                    }
                    
                    const foundationCards = gameState.foundations ? 
                        Object.values(gameState.foundations).reduce((sum, pile) => sum + (pile ? pile.length : 0), 0) : 0;
                    const foundationProgress = foundationCards / 52;
                    const faceUpCards = (gameState.tableau || []).reduce((sum, pile) => 
                        sum + (pile ? pile.filter(c => c && c.faceUp).length : 0), 0);
                    const emptySpaces = (gameState.tableau || []).filter(pile => !pile || pile.length === 0).length;
                    const blockedCards = (gameState.tableau || []).reduce((sum, pile) => 
                        sum + (pile ? pile.filter(c => c && !c.faceUp).length : 0), 0);
                    
                    return {
                        foundationProgress,
                        faceUpCards,
                        emptySpaces,
                        blockedCards,
                        stockRemaining: gameState.stock ? gameState.stock.length : 0,
                        wasteSize: gameState.waste ? gameState.waste.length : 0
                    };
                } catch (error) {
                    console.warn('Error in basic analysis:', error);
                    return {
                        foundationProgress: 0,
                        faceUpCards: 0,
                        emptySpaces: 0,
                        blockedCards: 0,
                        stockRemaining: 0,
                        wasteSize: 0
                    };
                }
            }
            
            performStrategicAnalysis(gameState) {
                try {
                    const insights = [];
                    let difficulty = 'medium';
                    let strategicValue = 0;
                    let foundationGap = 0;
                    let longSequences = 0;
                    
                    if (!gameState) {
                        return {
                            insights: ['Strategic analysis unavailable - no game state'],
                            difficulty: 'medium',
                            strategicValue: 0,
                            foundationGap: 0,
                            longSequences: 0,
                            complexityScore: 3
                        };
                    }
                    
                    // Analyze foundation balance
                    if (gameState.foundations) {
                        const foundations = Object.values(gameState.foundations).map(pile => pile ? pile.length : 0);
                        const maxFoundation = foundations.length > 0 ? Math.max(...foundations) : 0;
                        const minFoundation = foundations.length > 0 ? Math.min(...foundations) : 0;
                        foundationGap = maxFoundation - minFoundation;
                        
                        if (foundationGap <= 1) {
                            insights.push('Excellent foundation balance maintained');
                            strategicValue += 3;
                        } else if (foundationGap >= 4) {
                            insights.push('Foundation imbalance detected - focus on lagging suits');
                            strategicValue -= 2;
                        }
                    }
                    
                    // Analyze sequence opportunities with complete board vision
                    if (gameState.tableau && Array.isArray(gameState.tableau)) {
                        gameState.tableau.forEach(pile => {
                            if (pile && Array.isArray(pile) && pile.length > 1) {
                                let currentSequence = 0;
                                for (let i = pile.length - 1; i > 0; i--) {
                                    if (pile[i] && pile[i-1] && pile[i].faceUp && pile[i-1].faceUp &&
                                        pile[i-1].value === pile[i].value + 1 &&
                                        this.game.constants.RED_SUITS.has(pile[i-1].suit) !== this.game.constants.RED_SUITS.has(pile[i].suit)) {
                                        currentSequence++;
                                    } else {
                                        break;
                                    }
                                }
                                if (currentSequence >= 3) longSequences++;
                            }
                        });
                        
                        if (longSequences >= 2) {
                            insights.push('Multiple long sequences available for strategic moves');
                            strategicValue += 2;
                        }
                    }
                    
                    // Analyze hidden card potential
                    const hiddenHighValue = this.countHiddenHighValueCards(gameState);
                    if (hiddenHighValue.aces > 0) {
                        insights.push(`${hiddenHighValue.aces} hidden Ace(s) - prioritize revealing them`);
                    }
                    if (hiddenHighValue.kings > 0 && gameState.tableau && 
                        gameState.tableau.filter(pile => !pile || pile.length === 0).length > 0) {
                        insights.push(`${hiddenHighValue.kings} hidden King(s) available for empty spaces`);
                    }
                    
                    // Calculate difficulty
                    const hiddenCards = (gameState.tableau || []).reduce((sum, pile) => 
                        sum + (pile ? pile.filter(c => c && !c.faceUp).length : 0), 0);
                    const stockUsed = gameState.stock ? (24 - gameState.stock.length) : 0;
                    
                    const complexityScore = (
                        hiddenCards * 0.1 +
                        foundationGap * 0.2 +
                        stockUsed * 0.05
                    );
                    
                    if (complexityScore < 2) difficulty = 'easy';
                    else if (complexityScore < 4) difficulty = 'medium';
                    else if (complexityScore < 6) difficulty = 'hard';
                    else difficulty = 'expert';
                    
                    return {
                        insights,
                        difficulty,
                        strategicValue,
                        foundationGap,
                        longSequences,
                        complexityScore
                    };
                } catch (error) {
                    console.warn('Error in strategic analysis:', error);
                    return {
                        insights: ['Strategic analysis temporarily unavailable'],
                        difficulty: 'medium',
                        strategicValue: 0,
                        foundationGap: 0,
                        longSequences: 0,
                        complexityScore: 3
                    };
                }
            }
            
            performLearningAnalysis(gameState) {
                try {
                    const insights = [];
                    let confidenceBoost = 0;
                    
                    if (!gameState) {
                        return {
                            insights: ['Learning analysis unavailable - no game state'],
                            confidenceBoost: 0,
                            similarWinningGames: 0,
                            historicallySuccessfulMoves: 0,
                            totalLearningData: this.gameMemory.winningGames.length
                        };
                    }
                    
                    // Check against successful game patterns
                    const currentStateHash = this.hashGameState(gameState);
                    let similarWinningGames = 0;
                    
                    this.gameMemory.winningGames.forEach(game => {
                        try {
                            const gameStateToHash = game.gameState || game;
                            const similarity = this.calculateStateSimilarity(currentStateHash, this.hashGameState(gameStateToHash));
                            if (similarity > 0.7) {
                                similarWinningGames++;
                            }
                        } catch (hashError) {
                            // Skip this game if comparison fails
                        }
                    });
                    
                    if (similarWinningGames > 0) {
                        insights.push(`Similar to ${similarWinningGames} previously won game(s)`);
                        confidenceBoost += 0.2;
                    }
                    
                    // Check move success patterns
                    let historicallySuccessfulMoves = 0;
                    
                    try {
                        const availableMoves = this.game.ai.findAllPossibleMoves();
                        availableMoves.forEach(move => {
                            const pattern = `${move.type}-${move.card?.value}-${move.card?.suit}`;
                            const outcome = this.gameMemory.moveOutcomes.get(pattern);
                            if (outcome && outcome.successRate > 0.6) {
                                historicallySuccessfulMoves++;
                            }
                        });
                    } catch (moveError) {
                        console.warn('Error analyzing available moves:', moveError);
                    }
                    
                    if (historicallySuccessfulMoves > 0) {
                        insights.push(`${historicallySuccessfulMoves} historically successful move(s) available`);
                        confidenceBoost += 0.1;
                    }
                    
                    return {
                        insights,
                        confidenceBoost,
                        similarWinningGames,
                        historicallySuccessfulMoves,
                        totalLearningData: this.gameMemory.winningGames.length
                    };
                } catch (error) {
                    console.warn('Error in learning analysis:', error);
                    return {
                        insights: ['Learning analysis temporarily unavailable'],
                        confidenceBoost: 0,
                        similarWinningGames: 0,
                        historicallySuccessfulMoves: 0,
                        totalLearningData: this.gameMemory.winningGames.length
                    };
                }
            }
            
            calculateWinProbability(gameState, strategicAnalysis) {
                const basic = this.performBasicAnalysis(gameState);
                
                let winProb = 0.3; // Base probability
                
                // Foundation progress (40% weight)
                winProb += basic.foundationProgress * 0.4;
                
                // Face-up card ratio (20% weight)
                winProb += (basic.faceUpCards / 28) * 0.2;
                
                // Strategic factors (25% weight)
                winProb += Math.max(0, strategicAnalysis.strategicValue / 10) * 0.25;
                
                // Learning boost (10% weight)
                const learningAnalysis = this.performLearningAnalysis(gameState);
                winProb += learningAnalysis.confidenceBoost * 0.1;
                
                // Stock efficiency (5% weight)
                winProb += (1 - basic.stockRemaining / 24) * 0.05;
                
                return Math.min(0.95, Math.max(0.05, winProb));
            }
            
            generateAdvancedRecommendation(basicAnalysis, strategicAnalysis, learningAnalysis) {
                const foundationProgress = basicAnalysis.foundationProgress;
                const insights = [...strategicAnalysis.insights, ...learningAnalysis.insights];
                
                if (foundationProgress > 0.8) {
                    return `🏆 Victory is near! ${insights[0] || 'Focus on final foundation moves.'}`;
                } else if (foundationProgress > 0.6) {
                    return `💪 Strong position! ${insights[0] || 'Maintain strategic pressure on foundations.'}`;
                } else if (foundationProgress > 0.4) {
                    return `🎯 Good progress! ${insights[0] || 'Continue revealing cards and building sequences.'}`;
                } else if (strategicAnalysis.longSequences > 0) {
                    return `🔄 Strategic opportunity! ${insights[0] || 'Use long sequences to create foundation opportunities.'}`;
                } else {
                    return `🧠 Challenging position! ${insights[0] || 'Focus on revealing hidden cards and creating space.'}`;
                }
            }
            
            analyzeHiddenCards(gameState) {
                const hiddenInsights = [];
                let totalHiddenValue = 0;
                
                gameState.tableau.forEach((pile, pileIndex) => {
                    pile.forEach((card, cardIndex) => {
                        if (!card.faceUp) {
                            const strategicValue = this.calculateCardStrategicValue(card.suit, card.value);
                            totalHiddenValue += strategicValue;
                            
                            // AI knows what the hidden cards are
                            if (card.value === 1) {
                                hiddenInsights.push(`Hidden Ace of ${card.suit} in pile ${pileIndex + 1} (${pile.length - cardIndex} cards deep)`);
                            } else if (card.value === 13) {
                                hiddenInsights.push(`Hidden King of ${card.suit} in pile ${pileIndex + 1} (${pile.length - cardIndex} cards deep)`);
                            } else if (card.value >= 11) {
                                hiddenInsights.push(`Hidden ${card.rank} of ${card.suit} in pile ${pileIndex + 1} (${pile.length - cardIndex} cards deep)`);
                            }
                        }
                    });
                });
                
                return {
                    insights: hiddenInsights,
                    totalValue: totalHiddenValue,
                    count: hiddenInsights.length
                };
            }
            
            // Helper methods
            canRevealSoon(cardInfo) {
                if (cardInfo.location.startsWith('tableau-')) {
                    const pileIndex = parseInt(cardInfo.location.split('-')[1]);
                    const pile = this.game.state.tableau[pileIndex];
                    return cardInfo.position >= pile.length - 3; // Within 3 moves of top
                }
                return false;
            }
            
            canUseCardImmediately(card, gameState) {
                // Check if card can go to foundation
                if (this.game.rules.canPlaceOnFoundation(card)) {
                    return true;
                }
                
                // Check if card can go to tableau
                for (const pile of gameState.tableau) {
                    if (this.game.rules.canPlaceOnTableau(card, pile)) {
                        return true;
                    }
                }
                
                return false;
            }
            
            helpsFoundationBuilding(card, gameState) {
                const foundationPile = gameState.foundations[card.suit];
                const nextNeeded = foundationPile.length + 1;
                return card.value === nextNeeded;
            }
            
            moveCreatesOpportunityFor(move, futureCard) {
                // Check if the current move creates space or sequences for future card
                if (move.type === 'foundation' && futureCard.value === 1) {
                    return true; // Foundation moves create space for Aces
                }
                
                if (move.type === 'tableau' && move.card && futureCard.value === move.card.value - 1) {
                    const moveCardIsRed = this.game.constants.RED_SUITS.has(move.card.suit);
                    const futureCardIsRed = this.game.constants.RED_SUITS.has(futureCard.suit);
                    return moveCardIsRed !== futureCardIsRed; // Alternating colors
                }
                
                return false;
            }
            
            countHiddenHighValueCards(gameState) {
                let aces = 0, kings = 0, faces = 0;
                
                try {
                    if (!gameState || !gameState.tableau) {
                        return { aces: 0, kings: 0, faces: 0 };
                    }
                    
                    gameState.tableau.forEach(pile => {
                        if (pile && Array.isArray(pile)) {
                            pile.forEach(card => {
                                if (card && !card.faceUp) {
                                    if (card.value === 1) aces++;
                                    else if (card.value === 13) kings++;
                                    else if (card.value >= 11) faces++;
                                }
                            });
                        }
                    });
                } catch (error) {
                    console.warn('Error counting hidden high value cards:', error);
                }
                
                return { aces, kings, faces };
            }
            
            cloneGameState(gameState) {
                try {
                    if (!gameState) {
                        console.warn('Cannot clone null/undefined game state');
                        return this.createDefaultGameState();
                    }
                    
                    // Only include the deck arrays, foundations, and gameStats—omit 'game' and other managers
                    return {
                        stock: (gameState.stock || []).map(card => ({ 
                            id: card.id, suit: card.suit, value: card.value, faceUp: card.faceUp 
                        })),
                        waste: (gameState.waste || []).map(card => ({ 
                            id: card.id, suit: card.suit, value: card.value, faceUp: card.faceUp 
                        })),
                        tableau: (gameState.tableau || []).map(pile =>
                            (pile || []).map(card => ({ 
                                id: card.id, suit: card.suit, value: card.value, faceUp: card.faceUp 
                            }))
                        ),
                        foundations: gameState.foundations ? Object.fromEntries(
                            Object.entries(gameState.foundations).map(([suit, pile]) =>
                                [suit, (pile || []).map(card => ({ 
                                    id: card.id, suit: card.suit, value: card.value, faceUp: card.faceUp 
                                }))]
                            )
                        ) : { '♠': [], '♥': [], '♦': [], '♣': [] },
                        gameStats: gameState.gameStats ? {
                            moves: gameState.gameStats.moves || 0,
                            time: gameState.gameStats.time || 0,
                            score: gameState.gameStats.score || 0
                        } : { moves: 0, time: 0, score: 0 }
                    };
                } catch (error) {
                    console.warn('Error cloning game state:', error);
                    return this.createDefaultGameState();
                }
            }
            
            createDefaultGameState() {
                return {
                    stock: [],
                    waste: [],
                    tableau: Array.from({ length: 7 }, () => []),
                    foundations: { '♠': [], '♥': [], '♦': [], '♣': [] },
                    gameStats: { moves: 0, time: 0, score: 0 }
                };
            }
            
            hashGameState(gameState) {
                try {
                    if (!gameState) return 'empty';
                    
                    const state = {
                        foundations: gameState.foundations ? 
                            Object.entries(gameState.foundations).map(([suit, pile]) => `${suit}:${pile ? pile.length : 0}`) : [],
                        tableau: gameState.tableau ? 
                            gameState.tableau.map(pile => pile ? pile.length : 0) : [],
                        stock: gameState.stock ? gameState.stock.length : 0,
                        waste: gameState.waste ? gameState.waste.length : 0
                    };
                    return JSON.stringify(state);
                } catch (error) {
                    console.warn('Error hashing game state:', error);
                    return 'error_' + Date.now();
                }
            }
            
            calculateStateSimilarity(state1Hash, state2Hash) {
                // Simple similarity calculation - could be more sophisticated
                return state1Hash === state2Hash ? 1.0 : 0.5;
            }
            
            calculateGameDifficulty(gameState) {
                try {
                    if (!gameState) return 'medium';
                    
                    const hiddenCards = (gameState.tableau || []).reduce((sum, pile) => 
                        sum + (pile ? pile.filter(c => c && !c.faceUp).length : 0), 0);
                    const foundationProgress = gameState.foundations ? 
                        Object.values(gameState.foundations).reduce((sum, pile) => 
                            sum + (pile ? pile.length : 0), 0) / 52 : 0;
                    
                    if (hiddenCards <= 5 && foundationProgress > 0.5) return 'easy';
                    if (hiddenCards <= 15 && foundationProgress > 0.2) return 'medium';
                    if (hiddenCards <= 21) return 'hard';
                    return 'expert';
                } catch (error) {
                    console.warn('Error calculating game difficulty:', error);
                    return 'medium';
                }
            }
            
            getFallbackAnalysis(gameState) {
                const basic = this.performBasicAnalysis(gameState);
                return {
                    winProbability: basic.foundationProgress * 0.6 + 0.3,
                    difficulty: 'medium',
                    recommendation: 'Continue playing strategically',
                    stockRecommendation: { shouldDraw: true, reason: 'Standard progression' }
                };
            }
            
            // Memory-optimized data persistence
            async saveLearningData() {
                try {
                    // Use memory manager for efficient data structures
                    const learningData = {
                        version: '3.0', // Updated version for memory optimization
                        timestamp: Date.now(),
                        gameMemory: {
                            // Compress winning games for storage efficiency
                            winningGames: this.gameMemory.winningGames.slice(-30).map(game => {
                                try {
                                    const stateToCompress = game.gameState || game;
                                    return this.game.memory.compressGameState(stateToCompress);
                                } catch (error) {
                                    console.warn('Error compressing game state, using empty buffer:', error);
                                    return new Uint8Array(256);
                                }
                            }),
                            // Store move outcomes efficiently
                            moveOutcomes: Array.from(this.gameMemory.moveOutcomes.entries()).slice(-500),
                            sequencePatterns: Array.from(this.gameMemory.sequencePatterns.entries()).slice(-200),
                            // Include deadlock patterns for improved learning
                            deadlockPatterns: this.gameMemory.deadlockPatterns || {},
                            deadlockGames: (this.gameMemory.deadlockGames || []).slice(-20)
                        },
                        neuralWeights: this.neuralWeights,
                        // Store memory stats for analysis
                        optimizationStats: this.game.memory.getMemoryStats()
                    };
                    
                    // Use efficient storage with memory manager's pattern storage
                    this.game.memory.patternMap.forEach((entry, key) => {
                        this.game.storage.set(`pattern_${key}`, {
                            outcomes: Array.from(entry.outcomes),
                            count: entry.count,
                            successRate: entry.successRate
                        });
                    });
                    
                    this.game.storage.set('advanced_ml_learning_data', learningData);
                    
                    console.log(`🧠 Saved optimized learning data: ${learningData.gameMemory.winningGames.length} compressed games, ${this.game.memory.patternMap.size} patterns`);
                } catch (error) {
                    console.warn('Failed to save learning data:', error);
                }
            }
            
            async loadLearningData() {
                try {
                    const saved = this.game.storage.get('advanced_ml_learning_data');
                    if (saved) {
                        if (saved.version === '3.0') {
                            // Load compressed data efficiently with error handling
                            const compressedGames = saved.gameMemory.winningGames || [];
                            this.gameMemory.winningGames = [];
                            
                            compressedGames.forEach((compressed, index) => {
                                try {
                                    const gameState = this.game.memory.decompressGameState(compressed);
                                    if (gameState) {
                                        this.gameMemory.winningGames.push({
                                            gameState: gameState,
                                            won: true,
                                            timestamp: Date.now() // Approximated for efficiency
                                        });
                                    }
                                } catch (error) {
                                    console.warn(`Failed to decompress game ${index}:`, error);
                                }
                            });
                            
                            this.gameMemory.moveOutcomes = new Map(saved.gameMemory.moveOutcomes || []);
                            this.gameMemory.sequencePatterns = new Map(saved.gameMemory.sequencePatterns || []);
                            this.gameMemory.deadlockPatterns = saved.gameMemory.deadlockPatterns || {};
                            this.gameMemory.deadlockGames = saved.gameMemory.deadlockGames || [];
                            this.neuralWeights = { ...this.neuralWeights, ...saved.neuralWeights };
                            
                            // Load pattern data into memory manager with error handling
                            try {
                                const patternKeys = Object.keys(localStorage).filter(key => key.startsWith('pattern_'));
                                patternKeys.forEach(key => {
                                    try {
                                        const patternKey = key.replace('pattern_', '');
                                        const patternData = this.game.storage.get(key);
                                        if (patternData && patternData.outcomes) {
                                            this.game.memory.patternMap.set(patternKey, {
                                                outcomes: new Float32Array(patternData.outcomes),
                                                count: patternData.count || 0,
                                                successRate: patternData.successRate || 0
                                            });
                                        }
                                    } catch (patternError) {
                                        console.warn(`Failed to load pattern ${key}:`, patternError);
                                    }
                                });
                            } catch (error) {
                                console.warn('Failed to load pattern data:', error);
                            }
                            
                            console.log(`🧠 Loaded optimized learning data: ${this.gameMemory.winningGames.length} games, ${this.game.memory.patternMap.size} patterns, ${Object.keys(this.gameMemory.deadlockPatterns).length} deadlock patterns`);
                        } else if (saved.version === '2.0') {
                            // Legacy data migration
                            this.gameMemory.winningGames = saved.gameMemory.winningGames || [];
                            this.gameMemory.moveOutcomes = new Map(saved.gameMemory.moveOutcomes || []);
                            this.gameMemory.sequencePatterns = new Map(saved.gameMemory.sequencePatterns || []);
                            this.neuralWeights = { ...this.neuralWeights, ...saved.neuralWeights };
                            
                            console.log(`🧠 Migrated legacy learning data: ${this.gameMemory.winningGames.length} games`);
                            // Save in new format
                            setTimeout(() => this.saveLearningData(), 1000);
                        }
                    }
                } catch (error) {
                    console.warn('Failed to load learning data:', error);
                    // Clear potentially corrupted data
                    try {
                        localStorage.removeItem('advanced_ml_learning_data');
                        console.log('🧠 Cleared corrupted learning data, starting fresh');
                    } catch (clearError) {
                        console.warn('Failed to clear corrupted data:', clearError);
                    }
                }
            }
            
            dispose() {
                // Save learning data before cleanup
                this.saveLearningData();
                
                // Clear game memory to free up space
                this.gameMemory.winningGames.length = 0;
                this.gameMemory.losingGames = [];
                this.gameMemory.deadlockGames = [];
                this.gameMemory.moveOutcomes.clear();
                this.gameMemory.sequencePatterns.clear();
                this.gameMemory.positionEvaluations.clear();
                
                // Clear complete board tracking
                this.completeBoard.allCards.clear();
                this.completeBoard.hiddenCards.clear();
                this.completeBoard.stockOrder.length = 0;
                this.completeBoard.futureStockCards.length = 0;
                
                // Clear web AI cache
                this.webAICache.clear();
                
                this.isDisposed = true;
                this.isInitialized = false;
                console.log('🧠 Advanced ML resources cleaned up and learning data saved');
            }
        }

        // Memory Management System
        class MemoryManager {
            constructor() {
                this.pools = {
                    gameStates: [],
                    moveEvaluations: [],
                    cardObjects: [],
                    analysisResults: [],
                    historicalData: []
                };
                
                this.maxPoolSize = 100;
                this.memoryStats = {
                    allocations: 0,
                    deallocations: 0,
                    poolHits: 0,
                    poolMisses: 0
                };
                
                // Efficient data structures
                this.compactStateCache = new Map(); // LRU cache for game states
                this.patternMap = new Map(); // Efficient pattern storage
                this.moveHistory = new CircularBuffer(1000); // Memory-efficient history
                this.weakObjectMap = new WeakMap(); // Auto-cleanup object associations
                
                this.initializeMemoryMonitoring();
            }
            
            // Object Pool Management
            acquireGameState() {
                this.memoryStats.allocations++;
                
                if (this.pools.gameStates.length > 0) {
                    this.memoryStats.poolHits++;
                    const state = this.pools.gameStates.pop();
                    this.resetGameState(state);
                    return state;
                } else {
                    this.memoryStats.poolMisses++;
                    return this.createGameState();
                }
            }
            
            releaseGameState(state) {
                if (this.pools.gameStates.length < this.maxPoolSize) {
                    this.pools.gameStates.push(state);
                }
                this.memoryStats.deallocations++;
            }
            
            acquireMoveEvaluation() {
                this.memoryStats.allocations++;
                
                if (this.pools.moveEvaluations.length > 0) {
                    this.memoryStats.poolHits++;
                    const evaluation = this.pools.moveEvaluations.pop();
                    this.resetMoveEvaluation(evaluation);
                    return evaluation;
                } else {
                    this.memoryStats.poolMisses++;
                    return this.createMoveEvaluation();
                }
            }
            
            releaseMoveEvaluation(evaluation) {
                if (this.pools.moveEvaluations.length < this.maxPoolSize) {
                    this.pools.moveEvaluations.push(evaluation);
                }
                this.memoryStats.deallocations++;
            }
            
            acquireCardObject() {
                this.memoryStats.allocations++;
                
                if (this.pools.cardObjects.length > 0) {
                    this.memoryStats.poolHits++;
                    return this.pools.cardObjects.pop();
                } else {
                    this.memoryStats.poolMisses++;
                    return { id: '', suit: '', rank: '', value: 0, faceUp: false };
                }
            }
            
            releaseCardObject(card) {
                if (this.pools.cardObjects.length < this.maxPoolSize) {
                    this.pools.cardObjects.push(card);
                }
                this.memoryStats.deallocations++;
            }
            
            // Factory methods
            createGameState() {
                return {
                    stock: [],
                    waste: [],
                    tableau: Array.from({ length: 7 }, () => []),
                    foundations: { '♠': [], '♥': [], '♦': [], '♣': [] },
                    gameStats: { moves: 0, time: 0, score: 0 },
                    metadata: new Map() // Efficient metadata storage
                };
            }
            
            createMoveEvaluation() {
                return {
                    move: null,
                    aiScore: 0,
                    confidence: 0,
                    strategicReasoning: [],
                    riskAssessment: { risk: 0, reason: '' },
                    historicalValue: 0,
                    futurePlanning: 0,
                    metadata: new Map()
                };
            }
            
            // Reset methods for object reuse
            resetGameState(state) {
                state.stock.length = 0;
                state.waste.length = 0;
                state.tableau.forEach(pile => pile.length = 0);
                Object.values(state.foundations).forEach(pile => pile.length = 0);
                state.gameStats.moves = 0;
                state.gameStats.time = 0;
                state.gameStats.score = 0;
                state.metadata.clear();
            }
            
            resetMoveEvaluation(evaluation) {
                evaluation.move = null;
                evaluation.aiScore = 0;
                evaluation.confidence = 0;
                evaluation.strategicReasoning.length = 0;
                evaluation.riskAssessment.risk = 0;
                evaluation.riskAssessment.reason = '';
                evaluation.historicalValue = 0;
                evaluation.futurePlanning = 0;
                evaluation.metadata.clear();
            }
            
            // Compact State Representation with error handling
            compressGameState(gameState) {
                try {
                    if (!gameState) {
                        console.warn('Cannot compress null/undefined game state');
                        return new Uint8Array(256); // Return empty buffer
                    }
                    
                    // Create a compact, memory-efficient representation
                    const compressed = new Uint8Array(256); // Fixed-size buffer
                    let offset = 0;
                    
                    // Encode stock count (1 byte)
                    compressed[offset++] = Math.min(255, gameState.stock ? gameState.stock.length : 0);
                    
                    // Encode waste count (1 byte)
                    compressed[offset++] = Math.min(255, gameState.waste ? gameState.waste.length : 0);
                    
                    // Encode tableau state (7 bytes for pile sizes + cards info)
                    for (let i = 0; i < 7; i++) {
                        const pileLength = (gameState.tableau && gameState.tableau[i]) ? gameState.tableau[i].length : 0;
                        compressed[offset++] = Math.min(255, pileLength);
                    }
                    
                    // Encode foundation state (4 bytes)
                    const suits = ['♠', '♥', '♦', '♣'];
                    suits.forEach((suit, i) => {
                        const foundationLength = (gameState.foundations && gameState.foundations[suit]) ? 
                            gameState.foundations[suit].length : 0;
                        compressed[offset + i] = Math.min(255, foundationLength);
                    });
                    offset += 4;
                    
                    // Store game stats in remaining space
                    const view = new DataView(compressed.buffer);
                    const stats = gameState.gameStats || { moves: 0, time: 0, score: 0 };
                    view.setUint32(offset, stats.moves || 0, true);
                    view.setUint32(offset + 4, stats.time || 0, true);
                    view.setInt32(offset + 8, stats.score || 0, true);
                    
                    return compressed;
                } catch (error) {
                    console.warn('Error compressing game state:', error);
                    return new Uint8Array(256); // Return empty buffer on error
                }
            }
            
            decompressGameState(compressed) {
                try {
                    // Validate input
                    if (!compressed) {
                        console.warn('Cannot decompress null/undefined data');
                        return this.acquireGameState();
                    }
                    
                    // Ensure we have a proper Uint8Array
                    let validCompressed;
                    if (compressed instanceof Uint8Array) {
                        validCompressed = compressed;
                    } else if (compressed.buffer && compressed.buffer instanceof ArrayBuffer) {
                        validCompressed = new Uint8Array(compressed.buffer);
                    } else if (Array.isArray(compressed)) {
                        validCompressed = new Uint8Array(compressed);
                    } else {
                        console.warn('Invalid compressed data format, creating default state');
                        return this.acquireGameState();
                    }
                    
                    // Ensure minimum size
                    if (validCompressed.length < 20) {
                        console.warn('Compressed data too small, creating default state');
                        return this.acquireGameState();
                    }
                    
                    const state = this.acquireGameState();
                    let offset = 0;
                    
                    // Decode basic structure (size info only for efficiency)
                    const stockSize = validCompressed[offset++];
                    const wasteSize = validCompressed[offset++];
                    
                    // Skip detailed reconstruction for now - can be expanded as needed
                    offset += 7; // tableau sizes
                    offset += 4; // foundation sizes
                    
                    // Safely create DataView
                    if (validCompressed.buffer && validCompressed.buffer instanceof ArrayBuffer) {
                        const view = new DataView(validCompressed.buffer, validCompressed.byteOffset);
                        state.gameStats.moves = view.getUint32(offset, true);
                        state.gameStats.time = view.getUint32(offset + 4, true);
                        state.gameStats.score = view.getInt32(offset + 8, true);
                    } else {
                        // Fallback for corrupted data
                        state.gameStats.moves = 0;
                        state.gameStats.time = 0;
                        state.gameStats.score = 0;
                    }
                    
                    return state;
                } catch (error) {
                    console.warn('Error decompressing game state:', error);
                    return this.acquireGameState(); // Return default state
                }
            }
            
            // LRU Cache for frequent state lookups
            cacheGameState(key, state) {
                if (this.compactStateCache.size >= 200) {
                    // Remove oldest entry
                    const firstKey = this.compactStateCache.keys().next().value;
                    this.compactStateCache.delete(firstKey);
                }
                
                this.compactStateCache.set(key, this.compressGameState(state));
            }
            
            getCachedGameState(key) {
                if (this.compactStateCache.has(key)) {
                    // Move to end (LRU behavior)
                    const compressed = this.compactStateCache.get(key);
                    this.compactStateCache.delete(key);
                    this.compactStateCache.set(key, compressed);
                    return this.decompressGameState(compressed);
                }
                return null;
            }
            
            // Memory monitoring and cleanup
            initializeMemoryMonitoring() {
                // Monitor memory usage periodically
                setInterval(() => {
                    this.performMemoryCleanup();
                    this.logMemoryStats();
                }, 30000); // Every 30 seconds
            }
            
            performMemoryCleanup() {
                // Limit pool sizes if memory usage is high
                Object.keys(this.pools).forEach(poolName => {
                    const pool = this.pools[poolName];
                    if (pool.length > this.maxPoolSize) {
                        pool.splice(this.maxPoolSize);
                    }
                });
                
                // Clear old cache entries if cache is too large
                if (this.compactStateCache.size > 500) {
                    const entries = Array.from(this.compactStateCache.entries());
                    const keepEntries = entries.slice(-200); // Keep newest 200
                    this.compactStateCache.clear();
                    keepEntries.forEach(([key, value]) => {
                        this.compactStateCache.set(key, value);
                    });
                }
                
                // Trigger garbage collection hint (if available)
                if (window.gc && typeof window.gc === 'function') {
                    window.gc();
                }
            }
            
            logMemoryStats() {
                const stats = this.getMemoryStats();
                console.log(`🧠 Memory Stats: Pool hit rate: ${stats.hitRate}%, Active objects: ${stats.activeObjects}, Cache size: ${stats.cacheSize}`);
            }
            
            getMemoryStats() {
                const totalRequests = this.memoryStats.poolHits + this.memoryStats.poolMisses;
                const hitRate = totalRequests > 0 ? Math.round((this.memoryStats.poolHits / totalRequests) * 100) : 0;
                
                return {
                    hitRate,
                    activeObjects: this.memoryStats.allocations - this.memoryStats.deallocations,
                    cacheSize: this.compactStateCache.size,
                    poolSizes: Object.fromEntries(
                        Object.entries(this.pools).map(([name, pool]) => [name, pool.length])
                    )
                };
            }
            
            // Efficient pattern storage
            storePattern(pattern, outcome) {
                const key = this.hashPattern(pattern);
                if (!this.patternMap.has(key)) {
                    this.patternMap.set(key, {
                        pattern: pattern,
                        outcomes: new Float32Array(10), // Fixed-size array for efficiency
                        count: 0,
                        successRate: 0
                    });
                }
                
                const entry = this.patternMap.get(key);
                const index = entry.count % 10;
                entry.outcomes[index] = outcome ? 1 : 0;
                entry.count++;
                
                // Recalculate success rate efficiently
                let successes = 0;
                const dataLength = Math.min(entry.count, 10);
                for (let i = 0; i < dataLength; i++) {
                    successes += entry.outcomes[i];
                }
                entry.successRate = successes / dataLength;
            }
            
            hashPattern(pattern) {
                // Simple hash function for patterns
                let hash = 0;
                const str = JSON.stringify(pattern);
                for (let i = 0; i < str.length; i++) {
                    const char = str.charCodeAt(i);
                    hash = ((hash << 5) - hash) + char;
                    hash = hash & hash; // Convert to 32-bit integer
                }
                return hash.toString(36);
            }
            
            dispose() {
                // Clean up all resources
                Object.values(this.pools).forEach(pool => pool.length = 0);
                this.compactStateCache.clear();
                this.patternMap.clear();
                this.moveHistory.clear();
                console.log('🧠 Memory Manager disposed');
            }
        }
        
        // Circular Buffer for memory-efficient history storage
        class CircularBuffer {
            constructor(capacity) {
                this.capacity = capacity;
                this.buffer = new Array(capacity);
                this.size = 0;
                this.start = 0;
                this.end = 0;
            }
            
            push(item) {
                this.buffer[this.end] = item;
                this.end = (this.end + 1) % this.capacity;
                
                if (this.size < this.capacity) {
                    this.size++;
                } else {
                    this.start = (this.start + 1) % this.capacity;
                }
            }
            
            get(index) {
                if (index >= this.size) return undefined;
                return this.buffer[(this.start + index) % this.capacity];
            }
            
            getLast(count = 1) {
                const result = [];
                for (let i = Math.max(0, this.size - count); i < this.size; i++) {
                    result.push(this.get(i));
                }
                return result;
            }
            
            clear() {
                this.size = 0;
                this.start = 0;
                this.end = 0;
            }
            
            toArray() {
                const result = [];
                for (let i = 0; i < this.size; i++) {
                    result.push(this.get(i));
                }
                return result;
            }
        }

        // Initialize the game with better error handling and memory management
        let game = null;
        
        // Memory cleanup on page unload
        window.addEventListener('beforeunload', () => {
            if (game && game.memory) {
                console.log('🧠 Cleaning up memory manager...');
                game.memory.dispose();
            }
            if (game && game.ml) {
                console.log('🧠 Cleaning up ML system...');
                game.ml.dispose();
            }
        });
        
        function safeGameCall(methodPath, ...args) {
            try {
                if (!window.game) {
                    console.error('Game not initialized');
                    return false;
                }
                
                const pathParts = methodPath.split('.');
                let current = window.game;
                
                for (let i = 0; i < pathParts.length - 1; i++) {
                    if (!current[pathParts[i]]) {
                        console.error(`Game component ${pathParts[i]} not ready`);
                        return false;
                    }
                    current = current[pathParts[i]];
                }
                
                const method = current[pathParts[pathParts.length - 1]];
                if (typeof method !== 'function') {
                    console.error(`Method ${methodPath} not found`);
                    return false;
                }
                
                return method.apply(current, args);
            } catch (error) {
                console.error(`Error calling ${methodPath}:`, error);
                return false;
            }
        }
        
        // Register service worker for PWA functionality
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('./sw.js')
                    .then((registration) => {
                        console.log('🔧 SW registered: ', registration);
                    })
                    .catch((registrationError) => {
                        console.log('❌ SW registration failed: ', registrationError);
                    });
            });
        }

        function initializeGame() {
            try {
                console.log('🎮 Starting game initialization...');
                
                if (typeof KlondikeSolitaire === 'undefined') {
                    throw new Error('KlondikeSolitaire class is not defined');
                }
                
                game = new KlondikeSolitaire();
                window.game = game;
                
                // Load achievements data
                game.achievements.loadAchievements();
                
                // Apply the current theme
                game.ui.applyTheme();
                
                console.log('✅ Klondike Solitaire initialized successfully');
                
                if (game && game.ui && typeof game.ui.showNotification === 'function') {
                    setTimeout(() => {
                        try {
                            game.ui.showNotification('🎮 Game loaded successfully! Click "AI Hint" to test the enhanced hint system.', 'info', 4000);
                        } catch (notifError) {
                            console.error('Notification test failed:', notifError);
                        }
                    }, 1500);
                }
                
            } catch (error) {
                console.error('❌ Failed to initialize game:', error);
                
                const errorDiv = document.createElement('div');
                errorDiv.style.cssText = `
                    position: fixed;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    background: #ef4444;
                    color: white;
                    padding: 20px;
                    border-radius: 10px;
                    text-align: center;
                    z-index: 9999;
                    max-width: 400px;
                `;
                errorDiv.innerHTML = `
                    <h3>⚠️ Game Initialization Failed</h3>
                    <p><strong>Error:</strong> ${error.message}</p>
                    <button onclick="location.reload()" style="margin-top: 10px; padding: 8px 16px; background: white; color: #ef4444; border: none; border-radius: 5px; cursor: pointer; font-weight: bold;">
                        🔄 Refresh Page
                    </button>
                `;
                document.body.appendChild(errorDiv);
            }
        }
        
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initializeGame);
        } else {
            initializeGame();
        }
    </script>
</body>
</html>